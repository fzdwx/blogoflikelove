/*
 Navicat Premium Data Transfer

 Source Server         : test
 Source Server Type    : MySQL
 Source Server Version : 50649
 Source Host           : 47.112.150.204:3306
 Source Schema         : myblogs

 Target Server Type    : MySQL
 Target Server Version : 50649
 File Encoding         : 65001

 Date: 24/10/2020 18:08:43
*/

SET NAMES utf8mb4;
SET FOREIGN_KEY_CHECKS = 0;

-- ----------------------------
-- Table structure for blog
-- ----------------------------
DROP TABLE IF EXISTS `blog`;
CREATE TABLE `blog`  (
  `id` int(10) NOT NULL AUTO_INCREMENT COMMENT '自增id',
  `bid` varchar(200) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL COMMENT '博客id',
  `title` varchar(200) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL COMMENT '博客标题',
  `content` longtext CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL COMMENT '博客内容',
  `sort` int(1) NOT NULL DEFAULT 0 COMMENT '排序 越小越优先',
  `views` int(10) NOT NULL DEFAULT 0 COMMENT '浏览量',
  `author_id` varchar(200) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL COMMENT '作者id',
  `author_name` varchar(200) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL COMMENT '作者名',
  `author_avatar` varchar(500) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL COMMENT '作者头像',
  `category_id` int(10) NOT NULL COMMENT '问题分类id',
  `category_name` varchar(50) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL COMMENT '问题分类名称',
  `create_by` datetime(0) NULL DEFAULT NULL COMMENT '创建时间',
  `update_by` datetime(0) NULL DEFAULT NULL COMMENT '修改时间',
  `is_deleted` tinyint(1) UNSIGNED NULL DEFAULT 0 COMMENT '逻辑删除 1（true）已删除， 0（false）未删除',
  `love` int(8) NULL DEFAULT 0 COMMENT '点赞的人数',
  PRIMARY KEY (`id`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 72 CHARACTER SET = utf8 COLLATE = utf8_general_ci ROW_FORMAT = DYNAMIC;

-- ----------------------------
-- Records of blog
-- ----------------------------
INSERT INTO `blog` VALUES (1, 'test', '一、博客项目架构', '\n\n# 一、博客功能设计\n\n第一次写项目，功能可能较少···\n\n## 	博客：\n\n1.  有博客标题 + 博客内容\n2.  这个博客的访问量\n3.  能根据访量来排序，\n4.  能根据博客类型来分类\n5.  有博客评论\n\n\n\n## 	用户：\n\n1.  用户的详细信息\n2.  用户是否在线\n\n\n\n## 数据库设计\n\n>   设计思路\n\n**遵循j阿里java手册建表规范**\n\n*   表名都为小写\n\n*   表必备三个字段：主键，创建时间，修改时间,对应（id,create_by,update_by）\n*   表明尽量表名类型 __ 作用\n*   博客和用户==使用逻辑删除==（is_deleted）\n\n\n\n![image-20200904123915758](https://gitee.com/likeloveC/picture_bed/raw/master/img/8.26/20200904123922.png)\n\n*   sql参考\n*   https://gitee.com/kuangstudy/bbs_kuangstudy/blob/master/kuangshen.sql\n\n>   博客表（blog）\n\n用来保存用户发布的博客内容\n\n```sql\nCREATE TABLE `blog` (\n    `id` int(10) NOT NULL AUTO_INCREMENT COMMENT \'自增id\',\n    `bid` varchar(200) NOT NULL COMMENT \'博客id\',\n    `title` varchar(200) NOT NULL COMMENT \'博客标题\',\n    `content` longtext NOT NULL COMMENT \'博客内容\',\n    `sort` int(1) NOT NULL DEFAULT \'0\' COMMENT \'排序 越小越优先\',\n    `views` int(10) NOT NULL DEFAULT \'0\' COMMENT \'浏览量\',\n    `author_id` varchar(200) NOT NULL COMMENT \'作者id\',\n    `author_name` varchar(200) NOT NULL COMMENT \'作者名\',\n    `author_avatar` varchar(500) NOT NULL COMMENT \'作者头像\',\n    `category_id` int(10) NOT NULL COMMENT \'问题分类id\',\n    `category_name` varchar(50) NOT NULL COMMENT \'问题分类名称\',\n    `create_by` datetime NOT NULL COMMENT \'创建时间\',\n    `update_by` datetime NOT NULL COMMENT \'修改时间\',\n    `is_deleted` tinyint(1) unsigned NOT NULL DEFAULT \'0\' COMMENT \'逻辑删除 1（true）已删除， 0（false）未删除\',\n    PRIMARY KEY (`id`)\n) ENGINE=InnoDB  DEFAULT CHARSET=utf8;\n```\n\n\n\n>   博客分类表（blog_category）\n\n管理博客的分类\n\n~~~sql\nCREATE TABLE `blog_category` (\n    `id` bigint(40) NOT NULL AUTO_INCREMENT  COMMENT \'自增id\', \n    `category` varchar(50) NOT NULL COMMENT \'博客分类\',\n    `create_by` datetime NOT NULL COMMENT \'创建时间\',\n    `update_by` datetime NOT NULL COMMENT \'更新时间\',\n    PRIMARY KEY (`id`)\n) ENGINE=InnoDB  DEFAULT CHARSET=utf8;\n~~~\n\n\n\n>   博客评论表(blog_comment)\n\n管理用户的评论\n\n```sql\nCREATE TABLE `blog_comment` (\n    `id` int(10) NOT NULL AUTO_INCREMENT COMMENT \'自增id\',\n    `comment_id` varchar(200) NOT NULL COMMENT \'评论唯一id\',\n    `topic_category` int(1) NOT NULL COMMENT \'1博客 2问答\',\n    `topic_id` varchar(200) NOT NULL COMMENT \'评论主题id\',\n    `user_id` varchar(200) NOT NULL COMMENT \'评论者id\',\n    `user_name` varchar(200) NOT NULL COMMENT \'评论者昵称\',\n    `user_avatar` varchar(500) NOT NULL COMMENT \'评论者头像\',\n    `content` longtext NOT NULL COMMENT \'评论内容\',\n    `create_by` datetime NOT NULL COMMENT \'创建时间\',\n    `update_by` datetime NOT NULL COMMENT \'更新时间\',\n    `is_deleted` tinyint(1) unsigned NOT NULL DEFAULT \'0\' COMMENT \'逻辑删除 1（true）已删除， 0（false）未删除\',\n    PRIMARY KEY (`id`)\n) ENGINE=InnoDB  DEFAULT CHARSET=utf8;\n```\n\n\n\n\n\n>   用户表(user)\n\n管理用户\n\n```sql\nCREATE TABLE `user` (\n    `id` int(10) NOT NULL AUTO_INCREMENT COMMENT \'自增id\',\n    `uid` varchar(200) NOT NULL COMMENT \'用户编号\',\n    `username` varchar(100) NOT NULL COMMENT \'用户名\',\n    `password` varchar(200) NOT NULL COMMENT \'密码\',\n    `avatar` varchar(500)  DEFAULT null COMMENT \'用户头像\',\n    `login_date` datetime NOT NULL COMMENT \'登录时间\',\n    `create_by` datetime NOT NULL COMMENT \'创建时间\',\n    `update_by` datetime NOT NULL COMMENT \'更新时间\',\n     is_online  tinyint(1) unsigned           not null comment \'是否在线 1（true）在线， 0（false）离线\',\n    `is_deleted` tinyint(1) unsigned NOT NULL DEFAULT \'0\' COMMENT \'逻辑删除 1（true）已删除， 0（false）未删除\',\n    PRIMARY KEY (`id`)\n) ENGINE=InnoDB  DEFAULT CHARSET=utf8;\n```\n\n\n\n>   用户信息表(user_info)\n\n管理用户信息\n\n```sql\nCREATE TABLE `user_info` (\n    `uid` varchar(200) NOT NULL COMMENT \'自增id\',\n    `nickname` varchar(80) DEFAULT NULL COMMENT \'用户昵称\',\n    `realname` varchar(80) DEFAULT NULL COMMENT \'真实姓名\',\n    `qq` varchar(20) DEFAULT NULL COMMENT \'QQ\',\n    `wechat` varchar(200) DEFAULT NULL COMMENT \'WeChat\',\n    `email` varchar(500) DEFAULT NULL COMMENT \'邮箱\',\n    `phone` varchar(20) DEFAULT NULL COMMENT \'手机\',\n    `work` varchar(200) DEFAULT NULL COMMENT \'工作\',\n    `address` varchar(500) DEFAULT NULL COMMENT \'地址\',\n    `hobby` varchar(500) DEFAULT NULL COMMENT \'爱好\',\n    `intro` varchar(2000) DEFAULT NULL COMMENT \'自我介绍\'\n    `create_by` datetime NOT NULL COMMENT \'创建时间\',\n    `update_by` datetime NOT NULL COMMENT \'更新时间\',\n    `is_deleted` tinyint(1) unsigned NOT NULL DEFAULT \'0\' COMMENT \'逻辑删除 1（true）已删除， 0（false）未删除\'\n) ENGINE=InnoDB DEFAULT CHARSET=utf8;\n```\n\n\n\n\n\n\n\n# 二、项目构建\n\n## 1.技术选型\n\n由于是个人项目，所以所有框架的版本尽量用最新的版本\n\n*   Spring boot  - 2.3.3.RELEASE\n*   mybatisplus - 3.4.0\n*   swagger - 2.9.2\n*   lombok\n*   mysql-connector-java\n*   hutool-all\n*   spring-boot-devtools（开发时使用）\n\n暂时只用了这么多，详情可以==查看项目中的pom文件==\n\n\n\n## 2.BaseEntity\n\n由于所有表中都有id，create_by,update_by 这3个字段，所有可以把他们抽取出来单独做成一个实体类，让所有的实体类都继承这个BaseEntity\n\n```java\n@Data\n@EqualsAndHashCode (callSuper = false)\n@Accessors (chain = true)\npublic class BaseEntity implements Serializable {\n\n    private static final long serialVersionUID = 1L;\n\n    @ApiModelProperty (value = \"自增ID\")\n    @TableId (value = \"id\", type = IdType.AUTO)\n    private String id;\n\n    @ApiModelProperty (value = \"创建时间\")\n    @TableField (fill = FieldFill.INSERT)\n    private Date createBy;\n\n    @ApiModelProperty (value = \"更新时间\")\n    @TableField (fill = FieldFill.INSERT_UPDATE)\n    private Date updateBy;\n}\n```\n\n\n\n## 3.mp逆向-代码生成器\n\n详情查看\n\nhttps://baomidou.com/guide/generator.html\n\n```java\npublic class MpGenerator {\n    public static void main(String[] args) {\n        String prefix = \"myblogs\";\n        String moduleName = \"blog\";\n\n        // 1、创建代码生成器\n        AutoGenerator mpg = new AutoGenerator();\n\n        // 2、全局配置\n        GlobalConfig gc = new GlobalConfig();\n        gc.setAuthor(\"likelove\");\n        gc.setOpen(true); //生成后是否打开资源管理器\n        gc.setFileOverride(true); //重新生成时文件是否覆盖\n        gc.setServiceName(\"%sService\");    //去掉Service接口的首字母I\n        gc.setIdType(IdType.AUTO); //主键策略\n        gc.setDateType(DateType.ONLY_DATE);//定义生成的实体类中日期类型\n        gc.setSwagger2(true);//开启Swagger2模式\n        mpg.setGlobalConfig(gc);\n\n        // 3、数据源配置\n        DataSourceConfig dsc = new DataSourceConfig();\n        dsc.setUrl(\"jdbc:mysql://localhost:3306/\" + prefix + \"?serverTimezone=GMT%2B8\");\n        dsc.setDriverName(\"com.mysql.cj.jdbc.Driver\");\n        dsc.setUsername(\"root\");\n        dsc.setPassword(\"rootroot\");\n        dsc.setDbType(DbType.MYSQL);\n        mpg.setDataSource(dsc);\n\n        // 4、包配置\n        PackageConfig pc = new PackageConfig();\n        pc.setModuleName(moduleName); //模块名\n        pc.setParent(\"com.lk\");\n        pc.setController(\"controller\");\n        pc.setEntity(\"entity\");\n        pc.setService(\"service\");\n        pc.setMapper(\"mapper\");\n        mpg.setPackageInfo(pc);\n\n        // 5、策略配置\n        StrategyConfig strategy = new StrategyConfig();\n        strategy.setNaming(NamingStrategy.underline_to_camel);//数据库表映射到实体的命名策略\n        strategy.setTablePrefix(moduleName + \"_\");//设置表前缀不生成\n        //\n        strategy.setColumnNaming(NamingStrategy.underline_to_camel);//数据库表字段映射到实体的命名策略\n        strategy.setEntityLombokModel(true); // lombok 模型 @Accessors(chain = true) setter链式操作\n\n        strategy.setLogicDeleteFieldName(\"is_deleted\");//逻辑删除字段名\n        strategy.setEntityBooleanColumnRemoveIsPrefix(true);//去掉布尔值的is_前缀\n\n        //自动填充\n        TableFill gmtCreate = new TableFill(\"gmt_create\", FieldFill.INSERT);\n        TableFill gmtModified = new TableFill(\"gmt_modified\", FieldFill.INSERT_UPDATE);\n        ArrayList<TableFill> tableFills = new ArrayList<>();\n        tableFills.add(gmtCreate);\n        tableFills.add(gmtModified);\n        strategy.setTableFillList(tableFills);\n\n        strategy.setRestControllerStyle(true); //restful api风格控制器\n        strategy.setControllerMappingHyphenStyle(true); //url中驼峰转连字符\n        mpg.setStrategy(strategy);\n\n        //设置BaseEntity\n        strategy.setSuperEntityClass(\" com.lk.blog.entity.base.BaseEntity\");\n        // 填写BaseEntity中的公共字段\n        strategy.setSuperEntityColumns(\"id\", \"create_by\", \"update_by\");\n\n        // 6、执行\n        mpg.execute();\n    }\n}\n```\n\n\n\n## 4.设置application资源文件\n\n```properties\n#项目启动端口\nserver.port=80\n#应用的名字\nspring.application.name=MyBlogs\n\n#应用数据库连接的配置\nspring.datasource.url=jdbc:mysql://localhost:3306/myblogs?serverTimezone=GMT%2B8\nspring.datasource.password=xxx\nspring.datasource.username=xxx\nspring.datasource.driver-class-name=com.mysql.cj.jdbc.Driver\n```\n\n\n\n\n\n## 5.启动\n\n**发现报错了**\n\n==springboot启动报错:\"Error starting ApplicationContext. To display the conditions report re-run your application with \'debug\' enabled.==\n\n**排查后**\n\n发现是mapper上的@mapper注解没有写，为每个mapper添加上注解后\n\n![image-20200904131725332](https://gitee.com/likeloveC/picture_bed/raw/master/img/8.26/20200904131725.png)\n\n\n\n启动成功\n\n![image-20200904131805325](https://gitee.com/likeloveC/picture_bed/raw/master/img/8.26/20200904131805.png)\n\n\n\n\n\n# 三、定义统一的数据返回形式\n\n## 设计思想\n\n由于返回的数据可能多种多样，所以定义一个统一的数据返回类型\n\n使用建造者模式设置返回数据的属性\n\n使用单例模式设置返回数据的类型\n\n### 定义一个返回数据的类\n\n*   设置4个属性\n\n    *   Boolean success  \n    *   Integer code\n    *   String message\n    *   Map<String, Object> data\n\n*   使用建造者模式的思想设置这4个属性的值\n\n    ```java\n    public class Result {\n        \n        ···\n        \n        public Result setSuccess(Boolean success) {\n            this.success = success;\n            return this;\n        }\n    \n        public Result setCode(Integer code) {\n            this.code = code;\n            return this;\n        }\n    \n        public Result setMessage(String message) {\n            this.message = message;\n            return this;\n        }\n    \n        public Result setData(Map<String, Object> data) {\n            this.data = data;\n            return this;\n        }\n    }\n    ```\n\n\n\n### 定义一个返回数据的枚举\n\nResultCodeEnum\n\n这个枚举中存放了所需要的各种返回结果\n\n*   设置3个属性，对应返回数据中的属性\n\n    ```java\n    private Boolean success;\n    private Integer code;\n    private String message;\n    ```\n\n*   以成功为例子\n\n    ```java\n    /** 成功 */\n    SUCCESS(true, 20000, \"成功\"),\n    ```\n\n详细内容 /src/main/java/com/lk/blog/entity/back/..\n\n\n\n\n\n\n\n\n\n# 四、定义一个返回数据的工具类\n\n## 原因：\n\n如图，如果==每次返回数据都要判断是否成功==，然后在返回数据会==造成代码冗余==，所以==提取==一个公共的返回结果==工具类==，来专门处理这类问题\n\n![image-20200904163752455](https://gitee.com/likeloveC/picture_bed/raw/master/img/8.26/20200904163752.png)\n\n\n\n\n\n## 工具类:\n\n暂时就想到了这两个方法，后续可能会根据实际使用添加\n\n==详情查看com/lk/blog/utils/ResultUtils==\n\n![image-20200904170852844](https://gitee.com/likeloveC/picture_bed/raw/master/img/8.26/20200904170852.png)\n\n\n\n\n\n\n\n# 五、BlogController简单的功能添加\n\n## 1.保存博客功能\n\n```java\n@RestController\n@RequestMapping (\"/blog\")\n@Api (tags = \"博客管理\")\npublic class BlogController {\n\n    	··· //注释太占位置就用省略号代替\n        @PostMapping (\"/save\")\n        @ApiOperation (value = \"保存博客\")\n        public Result save(@ApiParam (\"需要保存的博客\") Blog blog) {\n        log.info(\"save ：\" + blog);\n        boolean status = blogService.save(blog);\n        return ResultUtils.booleanData(status, \"保存成功\", \"保存失败，blog-save\");\n    }\n}\n}\n```\n\n\n\n## 2.根据id查询博客-阅读博客\n\n### a.方法实现思路\n\n```\n阅读博客\n1.获取这个博客\n2.需要查询相关的评论\n3.博客的浏览数要+1,写进数据库\n```\n\n-   在写这个方法的时候，发现我 ==Blog byId = blogService.getById(id);==这句代码是不会返回==boolean==的，所以上面的==booleanData(```)==方法就没有用了，我就在resultUtils中添加了一个 ==Result objectData(···)==方法\n\n![image-20200904171532149](https://gitee.com/likeloveC/picture_bed/raw/master/img/8.26/20200904171532.png)\n\n\n\n-   当我返回数据时发现要把这个blog保存到hashmap中，这又要写几行代码，所有我又抽取了一个一个方法==objPutInMap(String key, Object value)==到ResultUtils中\n\n    虽然这好像没有什么用······\n\n![image-20200904171706935](https://gitee.com/likeloveC/picture_bed/raw/master/img/8.26/20200904171706.png)\n\n![image-20200904175913307](https://gitee.com/likeloveC/picture_bed/raw/master/img/8.26/20200904175913.png)\n\n\n\n-   当我继续往下写的时候，我发现我还需要继续往这个map里面添加数据，所以我又写了一个方法\n\n    ![image-20200904175823212](https://gitee.com/likeloveC/picture_bed/raw/master/img/8.26/20200904175823.png)\n\n\n\n\n\n### b.代码实现\n\n当前这个方法还没有写完，步骤2   查询评论的功能需要等待评论中的条件查询方法一起写\n\n```java\n/**\n * 阅读博客\n * 1.获取这个博客\n * 2.需要查询相关的评论\n * 3.博客的浏览数要+1,写进数据库\n *\n * @param id 用户读取的博客\n *\n * @return Result\n */\n@GetMapping (\"/read/{id}\")\npublic Result read(@PathVariable Integer id) {\n    log.info(\"read id：\" + id);\n    //1.获取这个博客\n    Blog byId = blogService.getById(id);\n    //2.读取数据库中相关的评论\n    String bid = byId.getBid();\n    // TODO: 2020/9/4  根据bid 获取 评论\n    //3.博客的浏览数要+1\n    byId.setViews(byId.getViews() + 1);\n    //更新到数据库\n    blogService.updateById(byId);\n    //4.返回数据\n    HashMap<String, Object> data = ResultUtils.objPutInMap(\"blog\", byId);\n    return ResultUtils.objectData(\"查询成功\", \"查询失败，数据库中可能没有这个博客\", data);\n}\n```\n\n\n\n## 3.修改博客内容\n\n这是现在想到的方法，后续可能会更改\n\n```java\n/**\n * 修改博客的时候 博客数据回显\n *\n * @param id 需要回显的博客的id\n *\n * @return Result\n */\n@GetMapping (\"/edit/{id}\")\npublic Result echoBlog(@PathVariable Integer id) {\n    Blog byId = blogService.getById(id);\n    HashMap<String, Object> data = ResultUtils.objPutInMap(\"blog\", byId);\n    return ResultUtils.objectData(\"查询成功\", \"查询失败，数据库中可能没有这个博客\", data);\n}\n\n/**\n * 修改博客内容\n * @param blog 需要修改的博客\n * @return Result\n */\n@PutMapping (\"/edit\")\npublic Result edit(Blog blog) {\n    boolean status = blogService.updateById(blog);\n    return ResultUtils.booleanData(status, \"修改成功\", \"修改失败，数据库中可能没有这个博客\");\n}\n```\n\n\n\n\n\n## 4.删除博客\n\n这类操作留到单独的admin/AdminBlogController 里面写\n\n \n\n# 六、第一天总结\n\n准备比较仓促，写这个项目，主要我没有拿得出手的项目能写在简历上，二是想踩一下个人项目的各种坑，三是想检验一下自己学习的内容是否能拿出来用。\n\n明天的任务：\n\n1.  mp分页\n2.  mp自动填充 生成时间，修改时间\n3.  swagger路径分类\n4.  博客评论的相关方法能够完善，完善博客阅读的相关内容\n5.  暂时想到这么多\n\n希望自己能够加油\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n==上面全是套话，没什么说的，干就完了==', 200, 19076, 'like', 'like', 'test', 1, 'blog of likelove', '2020-01-01 00:00:00', '2020-09-23 17:44:49', 0, 22);
INSERT INTO `blog` VALUES (53, NULL, '二、博客mp插件', '明天的任务：\n\n1.  mp分页\n2.  mp自动填充 生成时间，修改时间\n3.  swagger路径分类\n4.  博客评论的相关方法能够完善，完善博客阅读的相关内容\n5.  暂时想到这么多\n\n\n\n# 一、mp 自动填充功能\n\n为BaseEntity的的==createBy==，和==updateBy==添加注解==@TableField==，根据FieldFill这个里面的字段\n\n![image-20200905081213892](https://gitee.com/likeloveC/picture_bed/raw/master/img/8.26/20200905081213.png)\n\n添加属性，详情查看com.lk.blog.entity.base.BaseEntity\n\n```java\npublic class BaseEntity implements Serializable {\n    ······\n    @ApiModelProperty (value = \"创建时间\")\n    @TableField (fill = FieldFill.INSERT)\n    private Date createBy;\n\n    @ApiModelProperty (value = \"更新时间\")\n    @TableField (fill = FieldFill.INSERT_UPDATE)\n    private Date updateBy;\n}\n```\n\n\n\n>   创建自动填充handel\n\n**问题：**\n\n用官方给出的设置自动填充功能，在我的项目中有bug，添加的数据不能自动填充\n\n```java\n  this.strictInsertFill(metaObject, \"createTime\", LocalDateTime.class, LocalDateTime.now()); // 起始版本 3.3.0(推荐使用)\n```\n\n![image-20200905083814315](https://gitee.com/likeloveC/picture_bed/raw/master/img/8.26/20200905083814.png)\n\n\n\n**解决**：\n\n使用通用填充： setFieldValByName，更多查看com.lk.blog.handle.MyMetaObjectHandler	\n\n![image-20200905084759889](https://gitee.com/likeloveC/picture_bed/raw/master/img/8.26/20200905084759.png)\n\n成功填充\n\n![image-20200905084716808](https://gitee.com/likeloveC/picture_bed/raw/master/img/8.26/20200905084716.png)\n\n\n\n\n\n# 二、swagger路径分类\n\n**思路：**\n\n为分前台用户请求，和后台管理请求\n\n\n\n## 先定义一个后端请求\n\n删除博客的请求\n\n```java\n@RestController\n@RequestMapping (\"/admin\")\n@Api (tags = \"博客后台管理\")\n@Slf4j\npublic class AdminBlogController {\n    @Resource\n    private BlogService blogService;//博客主类\n\n    //根据主键删除博客\n    @DeleteMapping (\"/blog/{id}\")\n    @ApiOperation (value = \"根据主键删除博客\")\n    public Result removeBlogById(@PathVariable String id) {\n        boolean b = blogService.removeById(id);\n        return ResultUtils.booleanData(b, \"删除成功\", \"删除失败\");\n    }\n}\n```\n\n\n\n## 添加MySwaggerConfig类中的方法\n\n更多查看 com.lk.blog.config.MySwaggerConfig\n\n![image-20200905093609517](https://gitee.com/likeloveC/picture_bed/raw/master/img/8.26/20200905093609.png)\n\n\n\n\n\n\n\n#  三、mp分页插件\n\n参考mp官网[分页插件][https://baomidou.com/guide/interceptor.html#%E5%88%86%E9%A1%B5%E6%8F%92%E4%BB%B6-paginationinnerinterceptor]\n\n## 1.mp分页配置\n\n==注意==：\n\n@mappersacn注解一定要扫描到mapper包，不然会报错\n\n```\ncom.lk.blog.config.MyBatisConfig;\n```\n\n![image-20200905130459979](https://gitee.com/likeloveC/picture_bed/raw/master/img/8.26/20200905130500.png)\n\n\n\n\n\n\n\n## 2.博客vo对象\n\n**原因**:\n\n方便我们进行条件查询，查询blog数据的时候，不用全部数据都查询出来，设计字段：\n\n-    String title 博客标题\n-    String authorName 作者姓名\n-    String categoryName 博客分类\n-    Integer viewsStart   浏览量的起始值\n-    Integer viewsEnd 浏览量的最大值\n\n刚开始只设计了 一个浏览量，来查询 >=这个数量的值，没有想到设计一个范围，当我想要查询比这个值小的数据时，无法查询，所以改进成了查询一个范围\n\n\n\n## 3.分页查询\n\n参考mybatis中的==BaseWrapper==中的方法\n\n![image-20200905131054169](https://gitee.com/likeloveC/picture_bed/raw/master/img/8.26/20200905131054.png)\n\n\n\n在BlogService定义自己的selectPage方法：\n\n![image-20200905131212022](https://gitee.com/likeloveC/picture_bed/raw/master/img/8.26/20200905131212.png)\n\n\n\n实现这个方法：\n\n**思路：**\n\n1.  通过queryWrapper按照Blog表中的字段先排序 （sort，views）\n2.  在通过BlogVo对象查询\n3.  通过Basewrapper.selectPage()方法返回数据\n\n```java\n@Service\npublic class BlogServiceImpl extends ServiceImpl<BlogMapper, Blog> implements BlogService {\n	···\n    @Override\n    public IPage<Blog> selectPage(Page<Blog> pageParam, BlogVo blogVo) {\n        //1.通过queryWrapper按照表中的sort和views字段排序\n        QueryWrapper<Blog> blogQw = new QueryWrapper<>();\n        blogQw.orderByAsc(\"sort\");\n        blogQw.orderByAsc(\"views\");\n        //2.按照条件查询对象查询\n        String title = blogVo.getTitle(); //博客标题\n        String authorName = blogVo.getAuthorName(); //博客作者\n        Integer viewsStart = blogVo.getViewsStart();//博客访问量\n        Integer viewsEnd = blogVo.getViewsEnd();\n        String categoryName = blogVo.getCategoryName(); //博客分类名字\n        if (title != null) {\n            blogQw.like(\"title\",title);\n        }\n        if (authorName != null) {\n            blogQw.like(\"author_name\",authorName);\n        }\n        if (categoryName != null) {\n            blogQw.eq(\"category_name\",categoryName);\n        }\n        if (!StringUtils.isEmpty(viewsStart)) {\n            blogQw.ge(\"views\",viewsStart);\n        }\n        if (!StringUtils.isEmpty(viewsEnd)) {\n            blogQw.le(\"views\", viewsEnd);\n        }\n        return baseMapper.selectPage(pageParam,blogQw);\n    }\n}\n```\n\n\n\n## 4.完成控制层方法\n\n**博客分页查询实现思路**\n\n * 1.定义一个pageParam，封装从前台传入的page，limit\n * 2.调用自定义的selectPage，封装pageParam，博客VO\n * 3.返回查询的数据\n\n```java\npublic class BlogController { \n    \n    ······\n    @GetMapping (\"/{page}/{limit}\")\n    public Result pageList(@ApiParam (\"当前页数\") @PathVariable long page,\n                           @ApiParam (\"每页多少条数据\") @PathVariable long limit,\n                           @ApiParam (\"博客条件查询对象\") BlogVo blogVo) {\n        log.info(\"======BlogController: pageList\");\n        Page<Blog> pageParam = new Page<>(page, limit);\n        IPage<Blog> iPage = blogService.selectPage(pageParam, blogVo);\n        List<Blog> blogList = iPage.getRecords();\n        HashMap<String, Object> data = ResultUtils.objPutInMap(\"blogList\", blogList);\n        return ResultUtils.objectData(\"查询成功\", \"查询失败\", data);\n\n    }\n   \n    ·····\n}\n```\n\n\n\n\n\n# 四、总结\n\n## 未完成：\n\n博客评论的相关方法能够完善，完善博客阅读的相关内容\n\n## 原因：\n\n学习前端内容，vue模块化，这后面几天应该都是', 1, 17, 'like', 'like', '1', 1, 'blog of likelove', '2020-09-11 10:27:29', '2020-09-12 08:37:48', 0, 0);
INSERT INTO `blog` VALUES (54, NULL, '三、博客前端架构', '# 一、关于博客评论系统\n\n先做个简易版的,评论楼中楼还没想好怎么写\n\n\n\n## 1.完善blogController中的阅读博客的方法：\n\n### a.**实现思路**\n\n-   a.根据bid找到这个博客相关的所有评论    bid -> topic_id\n-   b.根据创建时间排序           create_by\n-   c.需要查询的字段： content 内容， user_name 评论者昵称  user_avatar 评论者头像  create_by   创建时间\n\n\n\n### b.**定义业务层中方法-：**\n\n```java\npublic interface BlogCommentService extends IService<BlogComment> {\n\n    /**\n     * 根据博客id获取相关的评论\n     *\n     * @param topicId topicId 博客id\n     * @param columns 需要查询的列\n     *\n     * @return List<BlogComment>\n     */\n    List<BlogComment> getBlogByTopicId(String topicId, String... columns);\n}\n```\n\n\n\n### c.**实现业务层中的方法-BlogCommentServiceImpl：**\n\n思路：\n\n1.  通过mp的条件构造器查询所有等于bid的评论\n2.  然后根据创建时间排序\n3.  在选择需要查询的列 \n\n具体代码：\n\n```java\n@Override\npublic List<BlogComment> getBlogByTopicId(String topicId, String... columns) {\n    QueryWrapper<BlogComment> query = new QueryWrapper<>();\n    query.eq(\"topic_id\", topicId)\n         .orderByAsc(\"create_by\")\n         .select(columns);\n    return baseMapper.selectList(query);\n}\n```\n\n\n\n\n\n### d.**完善BlogController中的read方法**\n\n```\n具体查看：com.lk.blog.controller.BlogController.read···\n```\n\n```java\npublic Result read(@PathVariable Integer id) {\n    log.info(\"======BlogController: read\");\n    //1.获取这个博客\n    Blog byId = blogService.getById(id);\n    //2.读取数据库中相关的评论\n    String bid = byId.getBid();\n    //a.根据bid找到这个博客相关的所有评论    bid -> topic_id\n    //b.根据创建时间排序           create_by\n    //c.需要查询的字段： content 内容， user_name 评论者昵称  user_avatar 评论者头像  create_by   创建时间\n    List<BlogComment> blogComment = blogCommentService.getBlogByTopicId(bid, \"content\", \"user_name\", \"user_avatar\", \"create_by\");\n    //3.博客的浏览数要+1\n    byId.setViews(byId.getViews() + 1);\n    //更新到数据库\n    blogService.updateById(byId);\n    //4.返回数据\n    HashMap<String, Object> data = ResultUtils.objPutInMap(\"blog\", byId);\n    ResultUtils.objPutInMap(\"blogComment\", blogComment, data);\n    return ResultUtils.objectData(\"查询成功\", \"查询失败，数据库中可能没有这个博客\", data);\n}\n```\n\n\n\n# 二、今天是第四天\n\n昨天看了一天vue，今天先把前端架子搭起来\n\n\n\n\n\n## 前端使用框架：\n\nvue + element ui,准备用ant-design of vue，但是看了一下功能不是很好，所以还是element\n\n\n\n# 三、前端导航栏 topbar\n\n>   怎么点标题就能跳转页面？\n\n以去关于页面为例：\n\n绑定一个点击事件@click=goAbout，使用this.$router.push 方法路由\n\n~~~vue\n<script>\n    goAbout() {\n        this.$router.push({\n            path: \'/about\'\n        })\n    },\n</script>\n~~~\n\n详细代码：\n\n```vue\n<template slot-scope=\"scope\">\n    <el-row >\n        <el-menu :default-active=\"activeIndex\" mode=\"horizontal\"  aria-disabled>\n            <el-col :span=\"10\">\n                <!--左栏-->\n                <el-col :span=\"3\">\n                    <el-menu-item index=\"1\" @click=\"goHome\" class=\"leftcol el-icon-s-home\" >首页</el-menu-item>\n                </el-col>\n                <el-col :span=\"3\">\n                    <el-menu-item index=\"2\" @click=\"goBlog\" class=\"leftcol el-icon-notebook-1\">博客</el-menu-item>\n                </el-col>\n                <!--todo-->\n                <el-col :span=\"3\">\n                    <el-menu-item index=\"3\"  class=\"leftcol el-icon-data-board\">留言板</el-menu-item>\n                </el-col>\n                <el-col :span=\"3\">\n                    <el-menu-item index=\"4\" @click=\"goAbout\" class=\"leftcol el-icon-info\">关于</el-menu-item>\n                </el-col>\n            </el-col>\n            <!--中栏  搜索框-->\n            <el-col :span=\"2.9\">\n                <el-autocomplete class=\"el-zoom-in-center-enter-active\" style=\"margin: 2px\"\n                                 placeholder=\"请输入内容\"\n                                 @select=\"handleSelect\">\n                </el-autocomplete>\n            </el-col>\n            <el-col :span=4>\n                <el-col :span=2 style=\"position: fixed;right: 0;\">\n                    <el-submenu index=\"5\">\n                        <!--显示用户头像 + 名字 -->\n                        <template slot=\"title\">\n                            <el-avatar\n                                src=\"https://huyaimg.msstatic.com/avatar/1014/39/d0dba41e9a3db25510a8cc3065246c_180_135.jpg?1594368665\">\n                            </el-avatar>\n                        </template>\n                        <!--用户操作-->\n                        <el-menu-item index=\"2-1\">选项1</el-menu-item>\n                        <el-menu-item index=\"2-2\">选项2</el-menu-item>\n                        <el-menu-item index=\"2-3\">选项3</el-menu-item>\n                    </el-submenu>\n                </el-col>\n            </el-col>\n        </el-menu>\n    </el-row>\n</template>\n```\n\n\n\n## 效果\n\n![](https://gitee.com/likeloveC/picture_bed/raw/master/img/8.26/20200907132720.png)\n\n\n\n\n\n# 四、路由\n\n```js\nimport Vue from \'vue\'\nimport VueRouter from \'vue-router\'\n//懒加载\nconst Home = () => import(\'@/components/home\')\nconst about = () => import(\"@/components/about\")\nconst blog = () => import(\"@/views/blog/Blog\")\n\nVue.use(VueRouter)\n\nconst routes = [\n    {\n        path: \'/blog\',\n        name: \'blog\',\n        component: blog,\n        meta: {\n            title: \'博客 - Blog for Likelove\',\n        }\n    },\n    {\n        path: \'/\',\n        name: \'Home\',\n        component: Home,\n        meta: {\n            title: \'首页 - Blog for Likelove\',\n        }\n    },\n    {\n        path: \'/about\',\n        name: \'About\',\n        component: about,\n        meta: {\n            title: \'关于 - Blog for Likelove\',\n        }\n    }\n]\nconst router = new VueRouter({\n    mode: \'history\',\n    base: process.env.BASE_URL,\n    routes\n})\n//导航首位 动态修改标题 前置钩子\nrouter.beforeEach((to, from, next) => {\n    //from => to\n    document.title = to.meta.title\n    next()\n})\nexport default router\n```\n\n\n\n\n\n# 五、axios\n\n```js\nimport Axios from \"axios\";\n\n//全局axios设置\nexport function request(config) {\n    //1.创建实例\n     let axiosInstance = Axios.create({\n        baseURL: \'http://localhost:1211\',\n        timeout: 5000\n    });\n     //2.axios拦截器\n    //拦截请求\n    axiosInstance.interceptors.request.use(config => {\n        //todo 拦截 token 登录验证\n\n        return config\n    }, error => {\n        console.log(error);\n    });\n    //响应拦截\n    axiosInstance.interceptors.response.use(res=>{\n        //获取自定义的响应状态码  不等于 20000 就是失败  res.data.code != 20000\n        return res.data\n    }, error => {\n        console.log(error);\n    });\n    //发送真正的请求\n    return axiosInstance(config)\n}\n```\n\n\n\n\n\n# 六、注册到App中\n\n```vue\n<template>\n    <div id=\"app\">\n        <!--外层容器-->\n        <el-container>\n            <!--顶栏容器-->\n            <el-header>\n                <TopBar></TopBar>\n            </el-header>\n            <!--侧边栏容器。-->\n          <!--  <el-aside></el-aside>-->\n            <!--主要区域容器。-->\n            <el-main>\n                <router-view></router-view>\n            </el-main>\n            <!--底栏容器。-->\n         <!--   <el-footer>\n            </el-footer>-->\n        </el-container>\n    </div>\n</template>\n<script>\nimport TopBar from \"@/components/bar/TopBar\";\nexport default {\n    name: \'app\',\n    components: {\n        TopBar\n    }\n}\n</script>\n```\n\n\n\n\n\n\n\n# 七、调用一个接口\n\n>   目的\n\n点击导航栏的博客按钮能显示所有博客\n\n![image-20200907160219063](https://gitee.com/likeloveC/picture_bed/raw/master/img/8.26/20200907160219.png)\n\n\n\n## 1.定义一个api文件夹\n\n![image-20200907132847075](https://gitee.com/likeloveC/picture_bed/raw/master/img/8.26/20200907132847.png)\n\n\n\n定义方法：\n\n![image-20200907132914404](https://gitee.com/likeloveC/picture_bed/raw/master/img/8.26/20200907132914.png)\n\n\n\n## 2.定义一个view文件夹\n\n![image-20200907132957143](https://gitee.com/likeloveC/picture_bed/raw/master/img/8.26/20200907132957.png)\n\n\n\n>   定义blog里面的方法\n\n![image-20200907160022991](https://gitee.com/likeloveC/picture_bed/raw/master/img/8.26/20200907160023.png)\n\n\n\n\n\n## 3.测试\n\n>   效果：\n\n![image-20200907160246460](https://gitee.com/likeloveC/picture_bed/raw/master/img/8.26/20200907160246.png)\n\n\n\n\n\n\n\n# 八、实现跳转到博客阅读页面\n\n**思路：**\n\n-   给博客标题的绑定一个click事件\n-   通过这个方法实现路由跳转并传入当前博客的id号\n-   根据id查看到这个博客相关的内容\n\n\n\n## 1.在blogApi.js中定义axios方法\n\n```js\n//阅读博客\nread(id){\n    return request({\n        url:\'/blog/read\'+ id,\n        method:\'get\'\n    })\n}\n```\n\n\n\n\n\n## 2.定义BlogRead.vue页面到views\n\n```vue\n<template>\n    <div>这是阅读博客页面\n        {{blog}}\n    </div>\n</template>\n<script>\nimport blogApi from \"@/api/blog/blogApi\";\nexport default {\n    name: \"BlogRead\",\n    created() {\n        //通过url中的参数获取id 调用当前read方法\n        this.read(this.$route.params.id)\n    },\n    data() {\n        return {\n            blog: {}\n        }\n    },\n    methods: {\n        //发送axios请求\n        read(id) {\n            blogApi.read(id).then(res => {\n                    this.blog =res.data.blog\n            })\n        }\n    }\n}\n</script>\n```\n\n\n\n## 3.在router.index.js中添加路由\n\n```js\n{\n    path: \'/blog/read/:id\',\n    component: BlogRead,meta: {\n        title: \'博客浏览 - Blog of likelove\'\n    }\n},\n```\n\n\n\n\n\n## 4.在Blog.vue中绑定事件，添加跳转路由\n\n绑定事件\n\n![image-20200907161547270](https://gitee.com/likeloveC/picture_bed/raw/master/img/8.26/20200907161547.png)\n\n![image-20200907161600847](https://gitee.com/likeloveC/picture_bed/raw/master/img/8.26/20200907161600.png)\n\n\n\n## 5.测试效果：\n\n![image-20200907161647405](https://gitee.com/likeloveC/picture_bed/raw/master/img/8.26/20200907161647.png)\n\n\n\n\n\n## 6.美化一下：\n\n![image-20200907162049928](https://gitee.com/likeloveC/picture_bed/raw/master/img/8.26/20200907162049.png)\n\n# 九、添加编辑页面	\n\n## 1.使用markdown插件\n\n```js\nimport mavonEditor from \'mavon-editor\'\nimport \'mavon-editor/dist/css/index.css\'\nVue.use(mavonEditor)\n```\n\n\n\n## 2.添加edit组件\n\n![image-20200907173553200](https://gitee.com/likeloveC/picture_bed/raw/master/img/8.26/20200907173553.png)\n\n```vue\n<!--markdown编辑器-->\n<template>\n    <div id=\"main\">\n        <mavon-editor v-model=\"value\" style=\"height: 900px\"/>\n    </div>\n</template>\n<script>\nexport  default {\n    data(){\n        return{\n            value:\'欢迎来到 blog of likelove ！\'\n        }\n    }\n}\n</script>\n```\n\n\n\n## 3.引用到blogform中\n\n![image-20200907173612485](https://gitee.com/likeloveC/picture_bed/raw/master/img/8.26/20200907173629.png)\n\n![image-20200907173623606](https://gitee.com/likeloveC/picture_bed/raw/master/img/8.26/20200907173623.png)\n\n\n\n## 4.效果\n\n![image-20200907173723198](https://gitee.com/likeloveC/picture_bed/raw/master/img/8.26/20200907173723.png)\n\n\n\n\n\n\n\n## 5.问题：\n\n引用edit组件的时候，v-model绑定不到数据，直接用这个\n\n```vue\'\n<mavon-editor v-model=\"form.content\" style=\"height: 900px\"/>\n```\n\n就能绑定到，所以修改为下面的方式，不引用edit组件了![image-20200907193337388](C:%5CUsers%5Cpdd20%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200907193337388.png)\n\n\n\n\n\n# 十、增加保存博客的程序\n\n## 1.在blogapi中定义axios方法\n\n```js\nsaveMyBlog(blog) {\n    return request({\n        url:\'/blog/save\',\n        method:\'post\',\n        data:blog,\n    })\n}\n```\n\n\n\n## 2.设置路由\n\n![image-20200907200422579](https://gitee.com/likeloveC/picture_bed/raw/master/img/8.26/20200907200422.png)\n\n\n\n\n\n## 3.在blogform中定义方法\n\n![image-20200907200530846](https://gitee.com/likeloveC/picture_bed/raw/master/img/8.26/20200907200530.png)\n\n\n\n## 4.提交的数据库，数据全为null：\n\n提交请求的时候，数据全部是null，但是能consel.log打印出来\n\n**解决：**\n\n添加@RequestBody 注解\n\n![image-20200907200604094](https://gitee.com/likeloveC/picture_bed/raw/master/img/8.26/20200907200604.png)\n\n\n\n\n\n# 十一、根据路由判断保存还是修改\n\n![image-20200910223013244](https://gitee.com/likeloveC/picture_bed/raw/master/img/8.26/20200910223013.png)\n\n\n\n## 判断需不需要获取需要修改的博客\n\n![image-20200910223107983](https://gitee.com/likeloveC/picture_bed/raw/master/img/8.26/20200910223108.png)\n\n\n\n\n\n## 提交的时候判断是添加还是修改\n\n![image-20200910223200629](https://gitee.com/likeloveC/picture_bed/raw/master/img/8.26/20200910223200.png)\n\n\n\n\n\n具体查看\n\n\n\n![image-20200910223241445](https://gitee.com/likeloveC/picture_bed/raw/master/img/8.26/20200910223241.png)', 0, 4, 'like', 'like', '1', 1, 'blog of likelove', '2020-09-11 11:04:43', '2020-09-11 22:50:59', 0, 0);
INSERT INTO `blog` VALUES (55, NULL, '四、博客简单版评论功能', '# 一、设置springboot项目日期返回格式\n\n## 1.在application.properties添加关于jackson相关的配置：\n\n```properties\nspring.jackson.time-zone=GMT+8\nspring.jackson.date-format=yyyy-MM-dd HH:mm:ss\n```\n\n\n\n## 2.在需要特定格式的地方添加注解\n\n比如在BaseEntitiy中：\n\n```java\n@JsonFormat (timezone = \"GMT+8\", pattern = \"yyyy-MM-dd\")\n```\n\n![image-20200911093600876](https://gitee.com/likeloveC/picture_bed/raw/master/img/8.26/20200911093608.png)\n\n\n\n\n\n## 3.效果\n\n![image-20200911093646861](https://gitee.com/likeloveC/picture_bed/raw/master/img/8.26/20200911093646.png)\n\n\n\n\n\n# 二、返回博客排序\n\n![image-20200911105654806](https://gitee.com/likeloveC/picture_bed/raw/master/img/8.26/20200911105654.png)\n\n## 1.目的\n\n点击按钮，返回相应的排序数据\n\n\n\n## 2.思路\n\n*   定义一个方法，根据传入的值判断返回的数据是什么排序\n*   比如说传入1，返回根据浏览数升序排列的，传入2就返回根据浏览数据降序排列的\n\n\n\n\n\n## 3.后端实现\n\n### a.service层\n\n​	BlogServiceImpl\n\n```java\n/**\n * 根据传入的数字，返回特点的条件博客排序列表\n * 1:根据浏览数升序排列\n * 2:根据浏览数据降序排列\n * 3:根据修改时间升序排列\n * 4:根据修改时间降序排列\n *\n * @param status integer\n *\n * @return 博客列表\n */\n@Override\npublic List<Blog> getBlogListSort(Integer status) {\n    QueryWrapper<Blog> query = new QueryWrapper<>();\n    if (status == 1) {//1:根据浏览数升序排列\n        query.orderByAsc(\"views\");\n    }\n    else if (status == 2) {//2:根据浏览数据降序排列\n        query.orderByDesc(\"views\");\n    }\n    else if (status == 3) {//3:根据修改时间升序排列\n        query.orderByDesc(\"update_by\");\n    }\n    else if (status == 4) {//4:根据修改时间降序排列\n        query.orderByDesc(\"update_by\");\n    }\n    return baseMapper.selectList(query);\n}\n```\n\n\n\n### b.controller层实现\n\nBlogController\n\n```java\n/**\n * 获取博客排序列表\n *\n * @return Result\n */\n@GetMapping (\"/{status}\")\n@ApiOperation (value = \"返回所有博客\")\npublic Result getListSort(@ApiParam (\"排序状态\") @PathVariable Integer status) {\n    log.info(\"======BlogController: getListSort\");\n    List<Blog> blogList = blogService.getBlogListSort(status);\n    HashMap<String, Object> data = ResultUtils.objPutInMap(\"blogList\", blogList);\n    return ResultUtils.returnObjectDataIsNull(\"排序查询成功\", \"排序查询成功\", data);\n}\n```\n\n\n\n### c.测试\n\n![image-20200911113202182](C:%5CUsers%5Cpdd20%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200911113202182.png)\n\n\n\n发现输入3和输入4的结果是一样的，查看service层的代码后发现，两个都是desc，修改后结果正确\n\n![image-20200911113257778](https://gitee.com/likeloveC/picture_bed/raw/master/img/8.26/20200911113257.png)\n\n\n\n\n\n## 4.前端实现\n\n### 1.定义blogApi\n\n![image-20200911113632353](https://gitee.com/likeloveC/picture_bed/raw/master/img/8.26/20200911113632.png)\n\n\n\n### 2.定义blogShow方法\n\n![image-20200911114805384](https://gitee.com/likeloveC/picture_bed/raw/master/img/8.26/20200911114805.png)\n\n\n\n### 3.给按钮绑定事件\n\n根据语义做了修改\n\n![image-20200911114831613](https://gitee.com/likeloveC/picture_bed/raw/master/img/8.26/20200911114831.png)\n\n\n\n\n\n\n\n\n\n# 三、评论功能实现\n\n## 1.给评论表增加喜欢字段\n\n### a.love\n\n表示有多少人点赞了\n\n![image-20200911163646215](https://gitee.com/likeloveC/picture_bed/raw/master/img/8.26/20200911163646.png)\n\n在blogcomment的实体类中添加字段\n\n![image-20200911170610934](https://gitee.com/likeloveC/picture_bed/raw/master/img/8.26/20200911170610.png)\n\n\n\n### b.replayid 和 pid\n\n![image-20200911181223121](https://gitee.com/likeloveC/picture_bed/raw/master/img/8.26/20200911181223.png)\n\n![image-20200911181341187](https://gitee.com/likeloveC/picture_bed/raw/master/img/8.26/20200911181341.png)\n\n### c.评论分类\n\n-   直接对文章发表评论，pid与replyid为空；\n-   对一级评论进行回复，pid与replyid均为一级评论的id;\n-   对楼中楼进行回复，pid为一级评论的id，replyid为你回复的评论的id\n\n\n\n\n\n### d.问题：\n\n查询数据库的时候报错，原因：\n\n==新增的like字段冲突了，所有的like修改为love==\n\n![image-20200911174634442](https://gitee.com/likeloveC/picture_bed/raw/master/img/8.26/20200911174634.png)\n\n\n\n\n\n\n\n\n\n## 2.实现建议的评论功能\n\n即不考虑楼中楼，太麻烦了。。\n\n\n\n\n\n\n\n## 3.定义blogConmmentController中的方法\n\n![image-20200911211658290](https://gitee.com/likeloveC/picture_bed/raw/master/img/8.26/20200911211658.png)\n\n\n\n\n\n\n\n## 4.前端Api定义\n\n![image-20200911211716492](https://gitee.com/likeloveC/picture_bed/raw/master/img/8.26/20200911211716.png)\n\n\n\n## 5.评论提交方法\n\n![image-20200911211955905](https://gitee.com/likeloveC/picture_bed/raw/master/img/8.26/20200911211955.png)\n\n![image-20200911211950088](https://gitee.com/likeloveC/picture_bed/raw/master/img/8.26/20200911211950.png)\n\n## 6.获取评论方法\n\n![image-20200911212038536](https://gitee.com/likeloveC/picture_bed/raw/master/img/8.26/20200911212038.png)\n\n\n\n\n\n## 7.实时更新love数量\n\n### 1.前端现在的逻辑\n\n![image-20200911212115692](https://gitee.com/likeloveC/picture_bed/raw/master/img/8.26/20200911212115.png)\n\n\n\n### 2.后端实现\n\n*    传入id，根据这个评论的id获取并修改\n*    在传入一个状态，表示是增加还是减少\n\n```java\n@PutMapping (\"/{blogCommentId}/{status}\")\npublic Result updateLoveNum(@ApiParam (\"需要修改点赞人数评论\") @PathVariable Integer blogCommentId,\n                            @ApiParam (\"是加还是减\")   @PathVariable Integer status) {\n    log.info(\"==========BlogCommentService--- updateLoveNum:\" + blogCommentId);\n    BlogComment comment = blogCommentService.getById(blogCommentId);\n    if (status == 1) {\n        comment.setLove(comment.getLove() + 1);\n    }\n    else {\n        comment.setLove(comment.getLove() - 1);\n    }\n    boolean b = blogCommentService.updateById(comment);\n    return ResultUtils.returnBooleanDataIsNull(b, \"修改成功\", \"修改失败\");\n}\n```\n\n\n\n### 3.前端Api定义\n\n![image-20200911213215399](https://gitee.com/likeloveC/picture_bed/raw/master/img/8.26/20200911213215.png)\n\n\n\n### 4.修改前端逻辑\n\n![image-20200911213610864](https://gitee.com/likeloveC/picture_bed/raw/master/img/8.26/20200911213610.png)\n\n# 四、mark语法和html的转换\n\n## 1.引入jar包\n\n```xml\n<!--markdown - html-->\n<dependency>\n    <groupId>com.atlassian.commonmark</groupId>\n    <artifactId>commonmark</artifactId>\n    <version>0.15.2</version>\n</dependency>\n<dependency>\n    <groupId>com.atlassian.commonmark</groupId>\n    <artifactId>commonmark-ext-heading-anchor</artifactId>\n    <version>0.15.2</version>\n</dependency>\n<dependency>\n    <groupId>com.atlassian.commonmark</groupId>\n    <artifactId>commonmark-ext-gfm-tables</artifactId>\n    <version>0.15.2</version>\n</dependency>\n```\n\n\n\n## 2.实现方法\n\n```java\npackage com.lk.blog.utils;\n\n/**\n * @author likeLove\n * @time 2020-09-11  18:45\n */\npublic class MarkdownUtils {\n\n    /**\n     * markdown格式转换成HTML格式\n     *\n     * @param markdown\n     *\n     * @return\n     */\n    public static String markdownToHtml(String markdown) {\n        Parser parser = Parser.builder().build();\n        Node document = parser.parse(markdown);\n        HtmlRenderer renderer = HtmlRenderer.builder().build();\n        return renderer.render(document);\n    }\n\n    /**\n     * 增加扩展[标题锚点，表格生成]\n     * Markdown转换成HTML\n     *\n     * @param markdown\n     *\n     * @return\n     */\n    public static String markdownToHtmlExtensions(String markdown) {\n        //h标题生成id\n        Set<Extension> headingAnchorExtensions = Collections.singleton(HeadingAnchorExtension.create());\n        //转换table的HTML\n        List<Extension> tableExtension = Arrays.asList(TablesExtension.create());\n        Parser parser = Parser.builder()\n                              .extensions(tableExtension)\n                              .build();\n        Node document = parser.parse(markdown);\n        HtmlRenderer renderer = HtmlRenderer.builder()\n                                            .extensions(headingAnchorExtensions)\n                                            .extensions(tableExtension)\n                                            .attributeProviderFactory(new AttributeProviderFactory() {\n                                                @Override\n                                                public AttributeProvider create(AttributeProviderContext context) {\n                                                    return new CustomAttributeProvider();\n                                                }\n                                            })\n                                            .build();\n        return renderer.render(document);\n    }\n\n    /**\n     * 处理标签的属性\n     */\n    static class CustomAttributeProvider implements AttributeProvider {\n        @Override\n        public void setAttributes(Node node, String tagName, Map<String, String> attributes) {\n            //改变a标签的target属性为_blank\n            if (node instanceof Link) {\n                attributes.put(\"target\", \"_blank\");\n            }\n            if (node instanceof TableBlock) {\n                attributes.put(\"class\", \"ui celled table\");\n            }\n        }\n    }\n    public static void main(String[] args) {\n        String table = \"| hello | hi   | 哈哈哈   |\\n\" +\n                \"| ----- | ---- | ----- |\\n\" +\n                \"| 斯维尔多  | 士大夫  | f啊    |\\n\" +\n                \"| 阿什顿发  | 非固定杆 | 撒阿什顿发 |\\n\" +\n                \"\\n\";\n        String a = \"[imCoding 爱编程](http://www.lirenmi.cn)\";\n        System.out.println(markdownToHtmlExtensions(a));\n    }\n}\n```\n\n\n\n## 3.使用\n\n![image-20200911200151518](https://gitee.com/likeloveC/picture_bed/raw/master/img/8.26/20200911200151.png)\n\n\n\n## 4.效果\n\n![image-20200911200204627](https://gitee.com/likeloveC/picture_bed/raw/master/img/8.26/20200911200204.png)', 0, 4, 'like', 'like', '1', 1, 'blog of likelove', '2020-09-11 11:42:32', '2020-09-23 18:19:36', 0, 8888);
INSERT INTO `blog` VALUES (56, NULL, '项目部署以及优化方案', 'docker run -d -p 3306:3306 -v /etc/docker/myapp/mysql/conf:/etc/mysql/conf.d -e MYSQL_ROOT_PASSWORD=123123 --name myslq-blog mysql:5.7\n\n\n\n# 一、vue项目部署到docker中nginx上\n\n>   下载docker \n\nyum install docker\n\n\n\n>   安装nginx\n\ndocker pull nginx\n\n\n\n>   复制nginx的默认配置文件\n\n~~~bash\ndocker run nginx -d \ndocker  cp 53819f66428e:/etc/nginx/conf.d/default.conf /App/dockerNginx/conf/\ndocker  cp 53819f66428e:/etc/nginx/conf.d/default.conf /App/dockerNginx/conf.d/\n~~~\n\n\n\n>   停止这个镜像并删除\n\n~~~\ndocker stop xx\n\ndocker rm xx\n~~~\n\n\n\n>   编辑配置文件\n\n![image-20200909184007899](https://gitee.com/likeloveC/picture_bed/raw/master/img/8.26/20200909184007.png)\n\n\n\n>   在vue.config.js中添加配置\n\n![image-20200909184804739](https://gitee.com/likeloveC/picture_bed/raw/master/img/8.26/20200909184804.png)\n\n根据你运行情况看加不加\n\n\n\n>   nginx 压缩\n\n![image-20200910202641478](https://gitee.com/likeloveC/picture_bed/raw/master/img/8.26/20200910202648.png)\n\n~~~\ngzip on;\ngzip_http_version 1.1;\ngzip_comp_level 3;\ngzip_types text/plain application/json application/x-javascript application/css application/xml application/xml+rss text/javascript application/x-httpd-php image/jpeg image/gif image/png image/x-ms-bmp;\n~~~\n\n\n\n>   启动镜像\n\n~~~\ndocker run -d --name nginxfoblog -p 80:80 -v /App/dockerNginx/conf/nginx.conf:/etc/nginx/nginx.conf -v /App/dockerNginx/dist:/App/dockerNginx/dist -v //App/dockerNginx/conf.d/default.conf:/etc/nginx/conf.d/default.conf nginx\n~~~\n\n\n\n\n\n# 二、vue项目优化\n\n部署的时候，使用cdn的方法减少vue项目的大小，比如我们有vue，vue router，axios，element 等需要加载\n\n```html\n<script src=\" https://cdn.bootcss.com/vue/2.6.9/vue.min.js\"></script>\n<script src=\"https://cdn.bootcss.com/vue-router/3.0.1/vue-router.min.js\"></script>\n<script src=\"https://cdn.bootcdn.net/ajax/libs/axios/0.20.0/axios.min.js\"></script>\n<script src=\"https://cdn.bootcdn.net/ajax/libs/element-ui/2.9.2/index.js\"></script>\n<link href=\"https://cdn.bootcdn.net/ajax/libs/element-ui/2.9.2/theme-chalk/index.css\" rel=\"stylesheet\">\n```\n\n## 1.需要安装插件\n\n```\n\"babel-plugin-component\": \"^1.1.1\",\n```\n\n\n\n## 2.修改main,js中的代码，注释掉\n\n![image-20200910210359038](https://gitee.com/likeloveC/picture_bed/raw/master/img/8.26/20200910210359.png)\n\n![image-20200910210454214](https://gitee.com/likeloveC/picture_bed/raw/master/img/8.26/20200910210454.png)\n\n\n\n## 3.添加vue.config.js中的配置\n\n```js\nconfigureWebpack: {\n    externals: {\n        \'vue\': \'Vue\',\n        \'vue-router\': \'VueRouter\',\n        \'axios\': \'axios\',\n        \'element-ui\': \'ELEMENT\',\n    }\n},\n```\n\n![image-20200910210516662](https://gitee.com/likeloveC/picture_bed/raw/master/img/8.26/20200910210516.png)\n\n\n\n## 4.路由组件都启用懒加载模式\n\n```\ncomponent: resolve => require([\'@/views/blog/BlogRead\'], resolve),\n```\n\n![image-20200910210604820](https://gitee.com/likeloveC/picture_bed/raw/master/img/8.26/20200910210604.png)\n\n\n\n\n\n# 三、制作springboot项目的docker镜像\n\n![image-20200910222039705](https://gitee.com/likeloveC/picture_bed/raw/master/img/8.26/20200910222039.png)\n\n\n\n>   制作镜像\n\ndocker build -t blogforjava .\n\n![image-20200910222612539](https://gitee.com/likeloveC/picture_bed/raw/master/img/8.26/20200910222612.png)\n\n\n\n>   启动\n\n~~~\n[root@like javaapp]# docker run -d --name blog-like -p 8888:8888 likelove-blog \nd9b22f55986a8f0ab05fd2b9501b99b47be13954ced77bbedb00e37d174bb9d9\n[root@like javaapp]# \n~~~\n\n\n\n![image-20200910222728451](https://gitee.com/likeloveC/picture_bed/raw/master/img/8.26/20200910222728.png)\n\n\n\n# 四、后台运行 \n\nnohup java -jar blog-0.0.1-SNAPSHOT.jar  >log 2>&1 &\n\n\n\n\n\n\n\n# 五、查看端口\n\n```\nnetstat  -lntup \n```', 0, 4, 'like', 'like', '1', 1, 'blog of likelove', '2020-09-11 12:01:00', '2020-09-16 12:24:53', 0, 1);
INSERT INTO `blog` VALUES (61, '1', '赞美', '铁汁你真牛啊', 0, 88890, 'cx', 'cx', '1', 1, 'no', '2020-09-12 15:21:50', '2020-10-20 11:20:27', 0, 88889);
INSERT INTO `blog` VALUES (63, NULL, '五、博客点赞，简单搜索功能，留言板完善', '# 一、任务\n\n*   实现点赞，点击能加，在点能够取消\n\n    ![image-20200911225439411](https://gitee.com/likeloveC/picture_bed/raw/master/img/8.26/20200911225439.png)\n\n*   实现搜索功能\n\n*   完善留言板\n\n*   能够显示时间，添加icon\n\n*   ![image-20200911225643508](https://gitee.com/likeloveC/picture_bed/raw/master/img/8.26/20200911225643.png)\n\n*   评论楼中楼。。。\n\n\n\n\n\n\n\n# 二、评论显示的修改\n\n## 1.移动发表评论的地方\n\n由于原来的模块是含有楼中楼系统的，所以每一层都有添加评论的地方\n\n![image-20200912090459118](https://gitee.com/likeloveC/picture_bed/raw/master/img/8.26/20200912090506.png)\n\n\n\n**修改后：**\n\n移动至最上面，并添加过度动画\n\n```html\n<transition name=\"el-zoom-in-center\">\n    <div v-show=\"show3\">\n        <el-input\n                  v-model=\"inputComment\"\n                  type=\"textarea\"\n                  :rows=\"3\"\n                  autofocus\n                  placeholder=\"写下你的评论\">\n        </el-input>\n        {{ inputComment }}\n        <div align=\"right\" style=\"padding: 10px\">\n            <el-button @click=\"show3 = !show3\">取消</el-button>\n            <el-button class=\"btn\" type=\"success\" round @click=\"commitComment(item)\">确定</el-button>\n        </div>\n    </div>\n</transition>\n```\n\n![image-20200912090556594](https://gitee.com/likeloveC/picture_bed/raw/master/img/8.26/20200912090556.png)\n\n\n\n\n\n\n\n# 三、查看博客点赞功能\n\n## 1.后端controller方法实现\n\n思路比较简单，具体在blogController中\n\n```java\n/**\n * 修改博客点赞数量，默认加一\n *\n * @param status 为1是加，其他是减\n * @param blogId 需要修改点赞数量的博客\n *\n * @return result\n */\n@PutMapping (\"/{blogId}/{status}\")\npublic Result loveBlog(@ApiParam (\"点赞是加还是减\") @PathVariable String status,\n                       @ApiParam (\"需要修改点赞数量的博客\") @PathVariable String blogId) {\n    Blog blog = blogService.getById(blogId);\n    Integer loveNum = blog.getLove();\n    if (loveNum == 1) {\n        blog.setLove(loveNum + 1);\n    }\n    else {\n        blog.setLove(loveNum - 1);\n    }\n    boolean b = blogService.updateById(blog);\n    return ResultUtils.returnBooleanDataIsNull(b, \"修改成功\", \"修改失败\");\n}\n```\n\n\n\n\n\n## 2.前端Api定义\n\n![image-20200912125616059](https://gitee.com/likeloveC/picture_bed/raw/master/img/8.26/20200912125616.png)\n\n\n\n## 3.前端方法定义\n\n![image-20200912125645589](https://gitee.com/likeloveC/picture_bed/raw/master/img/8.26/20200912125645.png)\n\n\n\n## 4.前端html代码\n\n![image-20200912125739701](https://gitee.com/likeloveC/picture_bed/raw/master/img/8.26/20200912125739.png)\n\n\n\n\n\n## 5.测试\n\n### 初始：\n\n![image-20200912130149828](https://gitee.com/likeloveC/picture_bed/raw/master/img/8.26/20200912130149.png)\n\n### 点击后：\n\n![image-20200912130207365](https://gitee.com/likeloveC/picture_bed/raw/master/img/8.26/20200912130207.png)\n\n### 刷新：\n\n![image-20200912130226399](https://gitee.com/likeloveC/picture_bed/raw/master/img/8.26/20200912130226.png)\n\n### 结果：\n\n前端逻辑没有问题，但是点赞次数变少了，查看后端代码，发现比较的loveNum，应该是status，修改后结果正确\n\n![image-20200912130320472](https://gitee.com/likeloveC/picture_bed/raw/master/img/8.26/20200912130320.png)\n\n# 四、修改阅读页面显示博客的地方\n\n## 1.原来的样子：用户能看到一些不需要的操作工具栏\n\n![image-20200912094628769](https://gitee.com/likeloveC/picture_bed/raw/master/img/8.26/20200912094628.png)\n\n![image-20200912094507759](https://gitee.com/likeloveC/picture_bed/raw/master/img/8.26/20200912094507.png)\n\n\n\n## 2.修改\n\n设定为不能修改，因为是阅读界面，留下用户需要的操作，默认开启markdown目录，设置为预览视图，设置为不能编辑，\n\n```html\n<mavon-editor\n       :toolbars=\"toolbars\" :editable=\"false\" :navigation=\"true\" :subfield=\"false\"      \n       :defaultOpen=\"\'preview\'\" :value=\"blog.content\"/>\n\n data() {\n        return {\n            toolbars: {\n                readmodel: true, // 沉浸式阅读\n                htmlcode: true, // 展示html源码\n                help: true, // 帮助         \n                navigation: true, // 导航目录      \n                subfield: true, // 单双栏模式\n                preview: true, // 预览\n            }\n\n        }\n    },\n```\n\n![image-20200912094740906](https://gitee.com/likeloveC/picture_bed/raw/master/img/8.26/20200912094740.png)\n\n\n\n\n\n# 五、实现简单的搜索功能\n\n由于目前还没有学过搜索引擎相关的框架，所以只能实现简单的搜索功能\n\n## 1.功能构思：\n\n输入博客的标题，根据关键字早数据库中查找，查找方式为： like  %key%\n\n另一种：\n\n 可以用第一次在后台获取的数据在前端根据title进行模糊查询，这样就不用一直请求后端数据了，但是我不知道前端的怎么写\n\n\n\n## 2.定义后端controller接口\n\nblogController.class\n\n```java\n /**\n     * 根据博客名查找博客\n     *\n     * @param blogTitle 需要查询的博客的标题\n     *\n     * @return result\n     */\n    @GetMapping (\"/searchBlog/{blogTitle}\")\n    @ApiOperation (value = \"根据博客名搜索博客\")\n    public Result searchBlogByTitle(@ApiParam (\"需要搜索的博客\") @PathVariable String blogTitle) {\n        log.info(\"==========BlogController====searchBlogByTitle:blogTitle:\" + blogTitle );\n        QueryWrapper<Blog> blogQueryWrapper = new QueryWrapper<>();\n        QueryWrapper<Blog> title = blogQueryWrapper.like(\"title\", blogTitle);\n        List<Blog> blogList = blogService.list(title);\n        for (Blog blog : blogList) {//markdown转化\n            blog.setContent(MarkdownUtils.markdownToHtml(blog.getContent()));\n        }\n        HashMap<String, Object> data = ResultUtils.objPutInMap(\"blogList\", blogList);\n        return ResultUtils.returnObjectDataIsNull(\"查询成功\", \"查询失败\", data);\n    }\n```\n\n\n\n\n\n\n\n## 3.前端Api定义\n\nblogApi.js\n\n~~~js\n //根据博客标题搜索博客\n    searchBlogByTitle(blogTitle) {\n        return request({\n            url:\'blog/searchBlog/\'+blogTitle,\n            method:\'get\'\n        })\n    },\n~~~\n\n\n\n\n\n## 4.在页面定义搜索博客功能\n\n**blogShow.vue**\n\n页面模板\n\n~~~html\n<div align=\"center\">\n    <el-autocomplete style=\"position: absolute;top: 20px\"\n                     v-model=\"searchValue\"\n                     class=\"inline-input\"\n                     :fetch-suggestions=\"querySearch\"\n                     placeholder=\"请输入要查找的博客标题...\"\n                     :trigger-on-focus=\"false\"\n                     value-key=\"name\"\n                     ></el-autocomplete>\n</div>\n~~~\n\n页面脚本\n\n\n\n```js\n//搜索请求数据\ndata() {\n    return {\n        foreverBlogList: \'\',\n        blogList: [],\n        searchValue: \'\',\n        preBlogList: [],\n    }\n},\n\n    methods: {\n        //搜索请求数据\n        querySearch(queryString, callback) {\n            blogApi.searchBlogByTitle(queryString).then(response => {\n                callback(response.data.blogList)\n                //判断当前从后端请求的博客列表是否为0\n                if (response.data.blogList.length !== 0) {\n                    //如果不为0\n                    this.blogList = response.data.blogList;\n                } else {\n                    this.blogList = this.foreverBlogList\n                    /*//判断上一个从后端请求的博客列表是否为空\n                    if (this.preBlogList.length === 0) {\n                        //如果为空就从新获取数据\n                        /!*  this.getData()*!/\n                        this.blogList = this.foreverBlogList;\n                    } else {\n                        //将当前从后端获取的博客列表当做后一个博客列表\n                        this.blogList = this.preBlogList;\n                    }*/\n                    this.$notify({\n                        type: \"warning\",\n                        title: \'搜索博客\',\n                        dangerouslyUseHTMLString: true,\n                        message: \'<strong>没有你要找的博客,标题：<i style=\"color: red;\" >\' + this.searchValue + \'</i></strong>\',\n                        offset: 100\n                    });\n                }\n                /* this.preBlogList = this.blogList;*/\n            })\n        },\n    }\n```\n\n  <div align=\"center\">\n            <el-autocomplete style=\"position: absolute;top: 20px\"\n                             v-model=\"searchValue\"\n                             class=\"inline-input\"\n                             :fetch-suggestions=\"querySearch\"\n                             placeholder=\"请输入要查找的博客标题...\"\n                             :trigger-on-focus=\"false\"\n                             value-key=\"name\"\n            ></el-autocomplete>\n        </div>\n\n\n\n\n# 六、明日\n\n*    评论功能出了问题，点击提交不能提交\n*    用户搜索评论的时候，如果为空就显示全部的，当前是显示当前的\n*    留言板还没有实现\n*    博客楼中楼还没有实现\n*    给博客点完赞后，刷新会消失，问题出现在赞数为0的博客中，其他有赞的情况是正常的\n     *   解决：查看数据库后发现love字段默认为是null，修改默认为0后显示正确\n*    用户模块。。。。', 0, 1, 'like', 'like', 'https://huyaimg.msstatic.com/avatar/1014/39/d0dba41e9a3db25510a8cc3065246c_180_135.jpg?1594368665', 0, 'blog of likelove', '2020-09-15 20:19:04', '2020-09-24 16:14:10', 0, 1);
INSERT INTO `blog` VALUES (64, NULL, '六、修复一些小问题', '# 一、今天\n\n*    评论功能出了问题，点击提交不能提交\n     *    解决\n*    用户搜索博客的时候，如果为空就显示全部的，当前是显示当前的\n     *    解决\n*    留言板还没有实现\n     *    完成\n*    博客楼中楼还没有实现\n*    给博客点完赞后，刷新会消失，问题出现在赞数为0的博客中，其他有赞的情况是正常的\n     *   解决：查看数据库后发现love字段默认为是null，修改默认为0后显示正确\n*    用户模块。。。。\n*    发现一个问题：点赞的时候会更新编辑时间\n     *    解决\n\n\n\n# 二、发现一个问题：点赞的时候会更新编辑时间\n\n问题：由于mybatis的自动填充功能，所以他会自动填充更新时间，修改为create_by，原来显示的是update_by\n\n\n\n\n\n\n\n# 三、修复不能提交评论的问题\n\n由于用户功能还没有完善，所以先定义一个默认的用户信息\n\n```js\ndata() {\n    return {\n        inputComment: \'\',\n        blogc:{\n            topicId:Number,\n            userName:String\n        }\n    }\n},\n\n\n    /**\n * 提交评论\n */\n    commitComment(/*blogcomment*/) {\n        /* console.log(blogcomment);*/\n        //对评论做初始化\n        /*blogcomment.content = this.inputComment;*/\n        this.blogc.content = this.inputComment;\n        this.blogc.topicId=this.$route.params.id\n        this.blogc.username=\'游客\'\n        blogApi.saveComments(this.blogc)\n        //页面刷新\n        this.$router.go(0)\n    },\n```\n\n\n\n\n\n效果：![image-20200913114932469](https://gitee.com/likeloveC/picture_bed/raw/master/img/8.26/20200913114932.png)\n\n\n\n\n\n\n\n# 四、留言板\n\n根据预先的设计\n\n```java\n@ApiModelProperty (value = \"1博客 2留言\")\nprivate Integer topicCategory;\n```\n\n所以留言的类型都为1\n\n\n\n## 1.后端controller接口定义\n\nBlogCommentController\n\n```java\n/**\n * 获取留言\n *\n * @return result\n */\n@GetMapping (\"\")\npublic Result getMessages() {\n    QueryWrapper<BlogComment> queryWrapper = new QueryWrapper<>();\n    queryWrapper.eq(\"topic_category\", 2);\n    List<BlogComment> blogMessages = blogCommentService.list(queryWrapper);\n    HashMap<String, Object> data = ResultUtils.objPutInMap(\"blogComments\", blogMessages);\n    return ResultUtils.returnObjectDataIsNull(\"查询留言成功\", \"查询留言失败\", data);\n}\n```\n\n\n\n\n\n## 2.前端Api定义\n\nblogApi\n\n```js\ngetMessages() {\n    return request({\n        url: \'/blog/comment\',\n        method: \'GET\',\n    });\n},\n```\n\n\n\n## 3.前端实现\n\n和评论差不多，具体查看\n\n![image-20200913130007697](https://gitee.com/likeloveC/picture_bed/raw/master/img/8.26/20200913130007.png)\n\n\n\n## 4.效果\n\n![image-20200913130048936](https://gitee.com/likeloveC/picture_bed/raw/master/img/8.26/20200913130049.png)\n\n\n\n\n\n\n\n\n\n\n\n# 五、明日：\n\n还差用户模块，以及后台管理，redis缓存等，现在可能先不写了，先去看一个项目，看完再来写', 0, 1, 'like', 'like', 'https://huyaimg.msstatic.com/avatar/1014/39/d0dba41e9a3db25510a8cc3065246c_180_135.jpg?1594368665', 0, 'blog of likelove', '2020-09-15 20:20:00', '2020-09-16 12:23:30', 0, 0);
INSERT INTO `blog` VALUES (65, NULL, '七、用户登录注册功能', '# 一、用户注册功能\n\n**思路：**\n\n1.  在页面获取用户注册信息，比如说用户名， 密码\n2.  传入后端，保存这个用户，以及用户信息\n3.  前端转跳到登录页面\n\n## 1.后端controller\n\n\n\n```java\n@PostMapping (\"/register\")\n@ApiOperation (value = \"注册用户\")\npublic Result registerUser(@RequestBody @ApiParam (\"需要注册的用户\") User user) {\n    log.info(\"==========UserController====registerUser:user:\" + user);\n    user.setUsername(user.getUid());\n    //保存这个用户的信息\n    UserInfo userInfo = new UserInfo();\n    userInfo.setUid(user.getUid());//当前用户的uid作为用户信息的uid\n    userInfo.setNickname(user.getUid());//当前用户的账号作为昵称\n    userInfoService.save(userInfo);//保存这个用户的用户信息\n    //保存这个用户\n    boolean save = userService.save(user);\n    return ResultUtils.returnBooleanDataIsNull(save, \"注册成功\", \"注册失败,用户名已经存在\");\n}\n```\n\n\n\n## 2.前端路由定义\n\nrouter.index.js\n\n```js\n//用户相关\n{\n    path: \'/user\',\n    name: \"user\",\n    meta: {\n        title: \'用户 - Blog of likelove\',\n    },\n    component: resolve => require([\'@/views/user/user\'], resolve),\n    children: [\n        //登录\n        {\n            path: \'login\',\n            name: \'login\',\n            meta: {\n                title: \'登录 - Blog of likelove\',\n            },\n            component: resolve => require([\'@/views/user/userLogin\'], resolve),\n        },\n        //注册\n        {\n            path: \'register\',\n            name: \'register\',\n            component: resolve => require([\'@/views/user/userReister\'], resolve),\n            meta: {\n                title: \'注册 - Blog of likelove\',\n            }\n        },\n    ]\n},\n```\n\n\n\n## 3.注册Api定义\n\napi.user.userApi\n\n```js\n//注册用户\nregisterUser(user) {\n    return request({\n        url:\'/blog/user/register\',\n        data:user,\n        method:\'post\'\n    })\n},\n```\n\n\n\n\n\n## 4.具体页面展示\n\n具体查看src/views/user/*,代码比较常规\n\n![image-20200914134435635](https://gitee.com/likeloveC/picture_bed/raw/master/img/8.26/20200914134435.png)\n\n\n\n\n\n# 二、登录功能\n\n**思路：**\n\n1.  根据从前端页面传入的数据封装成一个token\n2.  将这个token传到前端\n3.  前端保存token\n4.  跳转到首页\n\n## 1.引入jwt包\n\n```xml\n<dependency>\n   <groupId>io.jsonwebtoken</groupId>\n   <artifactId>jjwt</artifactId>\n   <version>0.7.0</version>\n</dependency>\n```\n\n\n\n## 2.定义工具类\n\n```java\npackage com.lk.blog.utils;\n\nimport com.lk.blog.entity.User;\nimport io.jsonwebtoken.*;\n\nimport javax.servlet.http.HttpServletRequest;\nimport java.util.Date;\nimport java.util.HashMap;\nimport java.util.Map;\n\n/**\n * @author likeLove\n * @time 2020-09-14  12:19\n */\npublic class JWTUtils {\n\n    //过期时间\n    public static final Integer expire = 1000 * 60 * 30;\n    public static final String App_secret = \"likelove\";\n	//传入user对象，返回响应的token\n    public static String genJwtToken(User user) {\n        //创建builder对象\n        JwtBuilder builder = Jwts.builder();\n        //第一步部分 jwt 头部 header\n        builder.setHeaderParam(\"alg\", \"HS256\");//签名算法\n        builder.setHeaderParam(\"typ\", \"JWT\");//令牌类型\n\n        //第二部分 有效载荷 playload\n        builder.setId(\"1\");//唯一标识\n        builder.setSubject(\"blog-of-likelive\");//令牌主题\n        builder.setIssuedAt(new Date(System.currentTimeMillis()));\n        builder.setExpiration(new Date(System.currentTimeMillis() + expire));//过期时间\n        //私有字段\n        String uid = user.getUid();\n        String password = user.getPassword();\n        builder.claim(\"uid\", uid);\n        builder.claim(\"password\", password);\n\n        //第三部分，签名哈希\n        builder.signWith(SignatureAlgorithm.HS256, App_secret);\n\n        //连接起来\n        return builder.compact();\n    }\n	\n    public static Map<String, Object> getTokenInfo(HttpServletRequest request) {\n        String token = request.getHeader(\"token\");\n        if (token != null) {\n            return null;\n        }\n        Jws<Claims> claimsJws = Jwts.parser().setSigningKey(App_secret).parseClaimsJws(token);\n        Claims body = claimsJws.getBody();\n        User user = new User();\n        user.setUid((String) body.get(\"uid\"));\n        user.setUsername((String) body.get(\"username\"));\n        user.setAvatar((String) body.get(\"Avatar\"));\n        user.setPassword((String) body.get(\"Password\"));\n        HashMap<String, Object> data = new HashMap<>();\n        data.put(\"user\",user);\n        return data;\n    }\n\n    public static boolean checkJwt(String token) {\n        if (token == null) {\n            return false;\n        }\n        try {\n            Jwts.parser().setSigningKey(App_secret).parseClaimsJws(token);\n        } catch (ExpiredJwtException e) {\n            e.printStackTrace();\n            return false;\n        }\n        return true;\n    }\n\n    public static boolean checkJwtHttpHeader(HttpServletRequest request) {\n        try {\n            String token = request.getHeader(\"token\");\n            if (token != null) {\n                return false;\n            }\n            Jwts.parser().setSigningKey(App_secret).parseClaimsJws(token);\n        } catch (ExpiredJwtException e) {\n            e.printStackTrace();\n            return false;\n        }\n        return true;\n    }\n \n}\n```\n\n\n\n## 3.定义service中的login方法\n\n传入一个用户生成token\n\nuserServiceImpl\n\n```java\n/**\n * 传递用户生成token\n *\n * @param user\n *\n * @return\n */\n@Override\npublic String login(User user) {\n    //校验：参数合法\n    String uid = user.getUid();\n    String password = user.getPassword();\n    QueryWrapper<User> query = new QueryWrapper<>();\n    query.eq(\"uid\", uid);\n    User inUser = baseMapper.selectOne(query);\n    if (inUser == null) {\n        throw new RuntimeException(\"用户不存在\");\n    }\n    if (!inUser.getPassword().equals(password)) {\n        throw new RuntimeException(\"密码错误\");\n    }\n    return JWTUtils.genJwtToken(user);\n}\n```\n\n\n\n## 4.定义controller中的方法\n\nuserController\n\n```java\n/**\n * 用户登录\n * @param user\n * @return\n */\n@PostMapping (\"/login\")\n@ApiOperation (value = \"登录\")\npublic Result loginUser(@RequestBody @ApiParam (\"需要登录的用户\") User user) {\n    log.info(\"==========UserController====loginUser:user:\" + user);\n    String token = userService.login(user);\n    HashMap<String, Object> data = ResultUtils.objPutInMap(\"token\", token);\n    return ResultUtils.returnObjectDataIsNull(\"登录成功\",\"登录失败，用户名或者密码错误\", data);\n}\n```\n\n\n\n\n\n## 5.前端Api\n\nuserApi\n\n```js\n//登录\nloginUser(user) {\n    return request({\n        url:\'/blog/user/login\',\n        data: user,\n        method:\'Post\'\n    });\n}\n```\n\n\n\n## 6.页面\n\n>   引入js-cookie \n\nnpm install js-cookie@2.2.0\n\n\n\n```js\n<script>\n    import userApi from \"../../api/user/userApi\";\nimport  cookie from \"js-cookie\"\nexport default {\n    name: \"login\",\n    data() {\n        return {\n            user: {\n                uid: \'\',\n                password: \'\',\n            },\n        }\n    },\n    methods: {\n        login() {\n            //执行调用远程登录接口\n            userApi.loginUser(this.user).then(res => {\n                //写入cookie\n                cookie.set(\"token\",res.data.token);\n                console.log(cookie.get(\"token\"));\n            });\n            //跳转到首页\n            this.$router.push(\"/\")\n        },\n    }\n}\n```\n\n\n\n\n\n# 三、回显用户数据\n\n**思路**\n\n1.  前端请求的时候加上一个请求头存放token\n2.  后端根据请求头中的token从数据库中查找数据，发送到前端\n3.  前端进行数据渲染\n\n## 1.后端controller定义\n\nusercontroller\n\n```java\n//回显数据\n@ApiOperation (value = \"数据回显\")\n@GetMapping(\"/getUserInfo\")\npublic Result getUserInfo(HttpServletRequest request) {\n    User user = JWTUtils.getTokenInfo(request);\n    UserInfo userInfo = userInfoService.getByUid(user);\n    HashMap<String, Object> data = new HashMap<>();\n    data.put(\"user\",user);\n    data.put(\"userInfo\", userInfo);\n    return Result.ok().setData(data).setMessage(\"获取成功\");\n}\n```\n\n\n\n## 2.前端Api定义\n\nuserApi\n\n```js\n//获取已经登录的用户数据\ngetLoginUserInfo(token) {\n    return request({\n        url:\'/blog/user/getUserInfo\',\n        method:\'get\',\n        //在请求头中定义一个字段：token\n        headers:{\n            \'token\':token\n        }\n    })\n},\n```\n\n\n\n\n\n## 3.headerBar显示数据\n\n### 脚本\n\n```js\nexport default {\n    name: \"homeBar\",\n    created() {\n        console.log(this.token);\n        this.getUserInfo();\n    },\n    data() {\n        return {\n            isLogin: true,\n            user:{},\n            userInfo:{},\n            token: cookie.get(\"token\"),\n        }\n    },\n    methods: {\n        getUserInfo() {\n            userApi.getLoginUserInfo(this.token).then(res => {\n                console.log(res);\n                this.user=res.data.user\n                this.userInfo=res.data.userInfo\n            });\n        },\n```\n\n\n\n\n\n### 用户栏\n\n```html\n<!--用户栏-->\n<el-col :span=\"4\">\n    <!--没有登录的时候-->\n    <el-menu v-show=\"isLogin\" class=\"el-menu-demo\" mode=\"horizontal\" background-color=\"#f1f1f1\"\n             text-color=\"#303133\">\n        <el-menu-item index=\"1\" @click=\"goLogin\">\n            <i class=\"my-icon-idenglu-copy\"></i>\n            登录\n        </el-menu-item>\n        <el-menu-item index=\"1\" @click=\"goRegister\">\n            <i class=\"my-icon-izhuce\"></i>\n            注册\n        </el-menu-item>\n    </el-menu>\n    <!--登录后-->\n    <div align=\"right\" v-show=\"!isLogin\">\n        <!--用户头像-->\n        <el-avatar :size=\"size\" :src=\"circleUrl\"></el-avatar>\n        <el-dropdown>\n            <div class=\"avatar-wrapper\">\n                <i class=\"el-icon-caret-bottom\"/>\n            </div>\n            <el-dropdown-menu slot=\"dropdown\" class=\"user-dropdown\">\n                <router-link class=\"inlineBlock\" to=\"/\">\n                    <el-dropdown-item>\n                        个人主页\n                    </el-dropdown-item>\n                </router-link>\n                <el-dropdown-item>\n                    选项1\n                </el-dropdown-item>\n                <el-dropdown-item divided>\n                    <span style=\"display:block;\" @click=\"logout\">注销</span>\n                </el-dropdown-item>\n            </el-dropdown-menu>\n        </el-dropdown>\n    </div>\n</el-col>\n```\n\n\n\n## 4.测试\n\n![image-20200914144909977](https://gitee.com/likeloveC/picture_bed/raw/master/img/8.26/20200914144910.png)\n\n\n\n\n\n# 四、在所有请求的前面添加请求头\n\n这样就可以不用在每一个请求方法加请求头了\n\n```js\n// request拦截器\nservice.interceptors.request.use(\n    config => {\n        //如果存在就添加并发送给服务器\n        if (cookie.get(\"blog-token\")) {\n            config.headers[\'token\']=cookie.get(\"blog-token\")\n        }\n        return config;\n    },\n    error => {\n        // Do something with request error\n        console.log(error) // for debug\n    }\n);\n```\n\n\n\n\n\n# 五、添加注销方法\n\n在headerbar中\n\n```js\nlogout() {\n    //清空token\n    cookie.remove(\"blog-token\")\n    //跳转页面\n    window.location.href = \'/\'\n},\n```\n\n\n\n\n\n# 六、修改保存博客的后端服务器方法\n\n因为已经添加了用户模块，所以可以根据当前登录的用户设置blog中对应的属性\n\n```java\n@PostMapping (\"/save\")\n@ApiOperation (value = \"保存博客\")\npublic Result save(@RequestBody @ApiParam (\"需要保存的博客\") Blog blog, HttpServletRequest request) {\n    //当前登录的用户\n    User user = JWTUtils.getTokenInfo(request);\n    //当前用户的数据\n    if (user != null) {\n        User byUid = userService.getByUid(user);\n        //保存给提交进来的博客\n        blog.setAuthorId(byUid.getUid());\n        blog.setAuthorName(byUid.getUsername());\n        blog.setAuthorAvatar(byUid.getAvatar());\n    }\n    log.info(\"======BlogController: save\" + blog);\n    boolean status = blogService.save(blog);\n    return ResultUtils.returnBooleanDataIsNull(status, \"保存成功\", \"保存失败，blog-save\");\n}\n```\n\n\n\n# 七、删除阅读博客可以修改的按键\n\n后面改为在自己主页地方才能修改\n\n![image-20200914181338625](https://gitee.com/likeloveC/picture_bed/raw/master/img/8.26/20200914181338.png)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n', 0, 1, 'like', 'like', 'https://huyaimg.msstatic.com/avatar/1014/39/d0dba41e9a3db25510a8cc3065246c_180_135.jpg?1594368665', 0, 'blog of likelove', '2020-09-15 20:20:34', '2020-09-16 12:23:34', 0, 0);
INSERT INTO `blog` VALUES (66, NULL, '八、用户个人信息页面', '# 一、用户个人详情页面的开发\n\n详情查看，这一节是关于userData\n\n![image-20200914201037074](https://gitee.com/likeloveC/picture_bed/raw/master/img/8.26/20200914201037.png)\n\n## 1.路由,router/index.js\n\n```js\n//用户个人信息\n{\n    path: \'/user/info\',\n        name: \'info\',\n            component: resolve => require([\'@/views/user/userINFO/userInfo\'], resolve),\n                children: [\n                    {\n                        path: \'\',\n                        name: \'userData\',\n                        component: resolve => require([\'@/views/user/userINFO/userData\'], resolve),\n                        meta: {\n                            title: \'myInfo - Blog of likelove\',\n                        },\n                    },\n                    {\n                        path: \'edit\',\n                        name: \'edit\',\n                        component: resolve => require([\'@/views/user/userINFO/userForm\'], resolve),\n                        meta: {\n                            title: \'编辑我的资料 - Blog of likelove\',\n                        },\n                    },\n\n                ]\n},\n```\n\n![image-20200914200745703](https://gitee.com/likeloveC/picture_bed/raw/master/img/8.26/20200914200745.png)\n\n\n\n## 2.绑定跳转方法\n\n给headerBar中绑定跳转方法\n\n![image-20200914201002910](https://gitee.com/likeloveC/picture_bed/raw/master/img/8.26/20200914201002.png)\n\n在创建页面完成后绑定访问页面\n\n![image-20200914200838249](https://gitee.com/likeloveC/picture_bed/raw/master/img/8.26/20200914200838.png)\n\n![image-20200914200930691](https://gitee.com/likeloveC/picture_bed/raw/master/img/8.26/20200914200930.png)\n\n![image-20200914200917822](https://gitee.com/likeloveC/picture_bed/raw/master/img/8.26/20200914200917.png)\n\n\n\n\n\n\n\n## 3.重新定义请求用户信息方法\n\n### a.usercontroller\n\n```js\n/**\n * 数据回显\n *\n * @param request http请求\n * @param status  1，只请求user，2就请求user和userinfo\n *\n * @return\n */\n@ApiOperation (value = \"数据回显\")\n@GetMapping (\"/getUserInfo/{status}\")\npublic Result getUserInfo(HttpServletRequest request,\n                          @ApiParam (\"1，只请求user，2就请求user和userinfo\") @PathVariable Integer status) {\n    log.info(\"==========UserController====getUserInfo:token:\" + request.getHeader(\"token\"));\n    HashMap<String, Object> data = null;\n    try {\n        User user = JWTUtils.getTokenInfo(request);\n        data = new HashMap<>(2);\n        User byUid = userService.getByUid(user);\n        if (status == 2) {//2就请求user和userinfo\n            UserInfo userInfo = userInfoService.getByUid(user);\n            data.put(\"userInfo\", userInfo);\n        }\n        data.put(\"user\", byUid);\n        return Result.ok().setData(data).setMessage(\"获取成功\");\n    } catch (Exception e) {\n        e.printStackTrace();\n    }\n    return Result.error().setCode(22222).setMessage(\"获取失败\");\n}\n```\n\n\n\n### b.userApi\n\n```js\n//获取已经登录的用户数据\ngetLoginUserInfo(status) {\n    return request({\n        url:\'/blog/user/getUserInfo/\'+status,\n        method:\'get\',\n        //在请求头中定义一个字段：token\n    })\n},\n```\n\n\n\n### c.修改headerBar中的方法\n\n![image-20200914185201577](https://gitee.com/likeloveC/picture_bed/raw/master/img/8.26/20200914185201.png)\n\n\n\n\n\n# 二、用户修改资料页面\n\nuserEdit，暂时不实现图片上传功能，阿里云oss有点贵，不用oss又优点麻烦，所以就这样！\n\n## 1.定义controller中的方法\n\nuserControoler\n\n```java\n/**\n * 修改用户资料\n *\n * @param userInfo 需要修改资料的用户\n *\n * @return result\n */\n@ApiOperation (value = \"修改资料\")\n@PostMapping (\"/edit\")\npublic Result updateUserInfo(@RequestBody @ApiParam (\"需要修改资料的用户\") UserInfo userInfo) {\n    log.info(\"==========UserController====updateUserInfo:userInfo:\" + userInfo);\n    boolean b = userInfoService.updateById(userInfo);\n    return ResultUtils.returnBooleanDataIsNull(b, \"修改成功\", \"修改失败\");\n}\n```\n\n\n\n## 2.定义api\n\nuserApi\n\n```java\n//修改资料\nupdateUserInfo(userInfo) {\n    return request({\n        url:\'/blog/user/edit\',\n        method:\'put\',\n        data:userInfo,\n    })\n},\n```\n\n\n\n## 3.页面方法\n\n![image-20200914202728447](https://gitee.com/likeloveC/picture_bed/raw/master/img/8.26/20200914202728.png)\n\n\n\n\n\n## 4.测试\n\n![image-20200914202807247](https://gitee.com/likeloveC/picture_bed/raw/master/img/8.26/20200914202807.png)\n\n\n\n![image-20200914202812449](https://gitee.com/likeloveC/picture_bed/raw/master/img/8.26/20200914202812.png)\n\n\n\n\n\n\n\n\n\n# 三、明日\n\n1.  根据用户查询对应的博客和浏览\n2.  博客标签分类\n3.  登录密码错误提示不友好\n4.  评论绑定到用户\n    5.  。。。', 0, 2, 'like', 'like', 'https://huyaimg.msstatic.com/avatar/1014/39/d0dba41e9a3db25510a8cc3065246c_180_135.jpg?1594368665', 0, 'blog of likelove', '2020-09-15 20:20:54', '2020-09-19 07:55:54', 0, 4);
INSERT INTO `blog` VALUES (67, NULL, '九、博客按标签分类', '# 一、今日\n\n1.  根据用户查询对应的博客和浏览\n2.  博客标签分类\n3.  登录密码错误提示不友好\n4.  评论绑定到用户\n5.  。。。\n\n\n\n# 二、登录密码错误提示\n\n![image-20200915161416863](https://gitee.com/likeloveC/picture_bed/raw/master/img/8.26/20200915161424.png)\n\n\n\n\n\n# 三、根据用户显示对应的博客\n\n**思路**：\n\n​	根据用户的uid查询响应的博客\n\n## 1.定义blogServiceImpl中的方法\n\n由于blogController中定义保存博客的方法是把用户的==Uid==和博客中的==AuthorId==绑定\n\n![image-20200915163209694](https://gitee.com/likeloveC/picture_bed/raw/master/img/8.26/20200915163209.png)\n\n所以：\n\n​	只选择了我们需要的\n\n```java\n//根据用户获取他所有的博客\n@Override\npublic List<Blog> getByAuthorId(User user) {\n    QueryWrapper<Blog> query = new QueryWrapper<>();\n    query.eq(\"author_id\", user.getUid())\n        //id主键，标题，浏览次数，点赞次数，作者uid，博客所属分类，创建时间\n        .select(\"id\",\"title\",\"views\",\"love\",\"author_id\",\"category_name\",\"create_by\");\n    return baseMapper.selectList(query);\n}\n```\n\n\n\n## 2.定义userController中的方法\n\n根据请求头中的token，获取对应的用户信息\n\n```java\n@ApiOperation (value = \"修改资料\")\n@GetMapping (\"/myBlog\")\npublic Result getMyBlog(@ApiParam (\"http请求\") HttpServletRequest request) {\n    //获取从token中保存的用户信息\n    User clientUser = JWTUtils.getTokenInfo(request);\n    //根据用户的uid获取对应的博客信息\n    List<Blog> blogList = blogService.getByAuthorId(clientUser);\n    HashMap<String, Object> data = ResultUtils.objPutInMap(\"blogList\", blogList);\n    return Result.ok().setData(data).setMessage(\"获取成功\");\n}\n```\n\n\n\n## 3.定义userApi的axios请求\n\ntoken已经在axios拦截器中定义了，所以在这里不需要再次定义\n\n```js\n//获取当前登录用户的博客信息：\ngetMyBlog() {\n    return request({\n        url:\'/blog/user/myBlog\',\n        method:\'get\',\n    });\n},\n```\n\n\n\n\n\n## 4.定义显示博客信息的路由\n\n![image-20200915164726177](https://gitee.com/likeloveC/picture_bed/raw/master/img/8.26/20200915164726.png)\n\n\n\n\n\n## 5.页面展示\n\n修改了一下UserController中的getMyBlog的代码，多传一个getSize的方法\n\n![image-20200915165559707](https://gitee.com/likeloveC/picture_bed/raw/master/img/8.26/20200915165559.png)\n\n具体：\n\n![image-20200915170811041](https://gitee.com/likeloveC/picture_bed/raw/master/img/8.26/20200915170811.png)\n\n\n\n## 6.添加跳转\n\n方法：\n\n```js\ngoBlogRead(id) {\n    this.$router.push({\n        path: \'/blog/read/\' + id,\n    })\n},\n```\n\n绑定：\n\n```html\n<el-button style=\"padding:3px 10px;font-size: 17px\" @click=\"goBlogRead(blog.id)\" type=\"text\">\n    博客标题：{{blog.title}},\n</el-button>\n```\n\n\n\n\n\n# 四、博客标签分类\n\n**思路：**\n\n1.  从后端请求当前有多少种博客分类\n2.  渲染到页面到，给用户选择\n\n## 1.定义BlogCategoryController中的方法\n\n```java\n@GetMapping(\"/list\")\n@ApiOperation (value = \"查询所有博客分类\")\npublic Result getAllBlogCategoryList() {\n    List<BlogCategory> blogCategoryList = blogCategoryService.list();\n    HashMap<String, Object> data = ResultUtils.objPutInMap(\"blogCategoryList\", blogCategoryList);\n    return Result.ok().setData(data).setMessage(\"获取成功\");\n}\n```\n\n## 2.定义BlogApi中axios请求\n\n```js\n//获取所有博客分类\ngetAllBlogCategory() {\n    return request({\n        url:\'/blog/category/list\',\n        method:\'get\'\n    })\n},\n```\n\n\n\n## 3.页面定义\n\n选择框：\n\n```html\ndiv>\n    <el-select v-model=\"blog.categoryName\" placeholder=\"请选择博客分类\">\n        <el-option\n            v-for=\"item in blogCategoryList\"\n            :key=\"item.value\"\n            :label=\"item.category\"\n            :value=\"item.category\">\n        </el-option>\n    </el-select>\n</div>\n```\n\n方法：\n\n```js\n//获取所有博客分类\ngetBlogCategoryList() {\n    blogApi.getAllBlogCategory().then(res => {\n        this.blogCategoryList = res.data.blogCategoryList\n    });\n},\n```\n\n\n\n## 4.在显示所有博客的页面，添加显示分类信息\n\n![image-20200915175022234](https://gitee.com/likeloveC/picture_bed/raw/master/img/8.26/20200915175022.png)\n\n![image-20200915175031101](https://gitee.com/likeloveC/picture_bed/raw/master/img/8.26/20200915175031.png)\n\n\n\n\n\n\n\n# 五、根据选择的博客分类显示博客\n\n![image-20200915184928676](https://gitee.com/likeloveC/picture_bed/raw/master/img/8.26/20200915184928.png)\n\n**思路**\n\n1.  给这个select框绑定一个click事件\n2.  传递当前选中分类的名字\n3.  然后发送的后端\n4.  后端查询数据库\n5.  返回数据到前端\n\n\n\n\n\n## 1.定义blogServiceImpl中的方法\n\n```java\n//根据博客分类名字返回属于分类的博客`\n@Override\npublic List<Blog> getByCategoryName(String categoryName) {\n    QueryWrapper<Blog> query = new QueryWrapper<>();\n    query.eq(\"category_name\",categoryName);\n    return baseMapper.selectList(query);\n}\n```\n\n\n\n## 2.BlogController方法定义\n\n```java\n/**\n * 根据博客分类返回对应的博客\n * @param categoryName 博客分类名字\n * @return Result\n */\n@ApiOperation (value = \"根据博客分类返回对应的博客\")\n@GetMapping (\"/Category/{categoryName}\")\npublic Result getBlogByCategoryName(@ApiParam (\"博客分类名字\") @PathVariable String categoryName) {\n    log.info(\"==========BlogController====getBlogByCategoryName:categoryName:\" + categoryName);\n    List<Blog> blogList = blogService.getByCategoryName(categoryName);\n    HashMap<String, Object> data = ResultUtils.objPutInMap(\"blogList\", blogList);\n    return Result.ok().setData(data).setMessage(\"获取成功\");\n}\n```\n\n\n\n## 3.blogApi定义\n\n```js\n//根据博客分类名字返回博客\ngetBlogByCategoryName(categoryName) {\n    return request({\n        url: \'/blog/Category/\' + categoryName,\n        method: \'get\'\n    })\n},\n```\n\n\n\n## 4.前端显示\n\n```js\n//根据博客分类名字，返回对应的博客\ngetBlogByCategory(n) {\n    if (n) {\n        blogApi.getBlogByCategoryName(n).then(res => {\n            this.blogList = res.data.blogList\n            this.foreverBlogList = res.data.blogList\n        });\n    }\n},\n```\n\n![image-20200915190453582](https://gitee.com/likeloveC/picture_bed/raw/master/img/8.26/20200915190453.png)\n\n\n\n\n\n## 5.测试\n\n![image-20200915190606449](https://gitee.com/likeloveC/picture_bed/raw/master/img/8.26/20200915190606.png)\n\n\n\n# 六、评论绑定到用户\n\n修改blogCommentController中的方法\n\n![image-20200915192915759](https://gitee.com/likeloveC/picture_bed/raw/master/img/8.26/20200915192915.png)\n\n\n\n\n\n# 七、给博客浏览页面的博客分类按钮绑定事件\n\n这样就可以点击，直接查看这个博客分类的所有属于这个博客分类的博客了\n\n![image-20200915193215183](https://gitee.com/likeloveC/picture_bed/raw/master/img/8.26/20200915193215.png)\n\n\n\n![image-20200915193535357](https://gitee.com/likeloveC/picture_bed/raw/master/img/8.26/20200915193535.png)\n\n\n\n\n\n\n\n\n\n# 八、明日\n\n1.  把显示博客页面修改为分页\n\n2.  根据博客分类显示的时候，显示的markdown的源代码\n\n    ![](https://gitee.com/likeloveC/picture_bed/raw/master/img/8.26/20200915201345.png)\n\n    1.  添加博客的时候，选择分类设置为强制', 0, 7, 'like', 'like', 'https://huyaimg.msstatic.com/avatar/1014/39/d0dba41e9a3db25510a8cc3065246c_180_135.jpg?1594368665', 0, 'blog of likelove', '2020-09-15 20:21:43', '2020-09-15 20:22:53', 0, 0);
INSERT INTO `blog` VALUES (68, NULL, '十、显示博客修改为分页方法', '# 一、今日\n\n1.  把显示博客页面修改为分页\n\n    解决\n\n2.  根据博客分类显示的时候，显示的markdown的源代码\n\n    已经修改为请求分页方法\n\n    ![](https://gitee.com/likeloveC/picture_bed/raw/master/img/8.26/20200915201345.png)\n\n3.  添加博客的时候，选择分类设置为强制、\n   解决\n\n4.  游客不能发表评论\n\n    解决\n\n\n\n# 二、修改为分页查询：\n\n## 1.修改blogController中的方法\n\n添加分页信息\n\n```java\n@GetMapping (\"/{page}/{limit}\")\n@ApiOperation (value = \"博客分页查询\")\npublic Result pageList(@ApiParam (\"当前页数\") @PathVariable long page,\n                       @ApiParam (\"每页多少条数据\") @PathVariable long limit,\n                       @RequestBody @ApiParam (\"博客条件查询对象\") BlogVo blogVo) {\n    log.info(\"==========BlogController====pageList:page:\" + page + \"---limit:\" + limit + \"---BlogVo\" + blogVo);\n    Page<Blog> pageParam = new Page<>(page, limit);\n    IPage<Blog> iPage = blogService.selectPage(pageParam, blogVo);\n    List<Blog> blogList = iPage.getRecords();\n    for (Blog blog : blogList) {//markdown转化\n        blog.setContent(MarkdownUtils.markdownToHtml(blog.getContent()));\n    }\n    //获取当前分页信息\n    long current = iPage.getCurrent();//当前页码数\n    long pages = iPage.getPages();//总页数\n    long total = iPage.getTotal();//总数据量\n    long size = iPage.getSize();//每页多少条数据量\n    HashMap<String, Object> data = ResultUtils.objPutInMap(\"blogList\", blogList);\n    data.put(\"current\", current);\n    data.put(\"pages\", pages);\n    data.put(\"total\", total);\n    data.put(\"size\", size);\n    return ResultUtils.returnObjectDataIsNull(\"查询成功\", \"查询失败\", data);\n}\n```\n\n## 2.定义blogApi的请求方法\n\n```js\n/**\n * 定义获取博客分页方法\n *\n * @param page 当前页数\n * @param limit 每页多少条数据\n * @param blogVo 博客条件查询对象\n */\ngetBlogByPage(page, limit, blogVo) {\n    return request({\n        url: \'/blog/\'+page+\'/\'+limit,\n        method: \'get\',\n        data:blogVo,\n    })\n},\n```\n\n## 3.显示分页页面的方法定义\n\n传入4个参数，初始化blogVo\n\n```js\n//调用分页请求\ngetBlogPage(title, authorName, categoryName, viewsStart, viewsEnd) {\n    this.blogVo.categoryName = categoryName;\n    this.blogVo.title=title;\n    this.blogVo.authorName= authorName;\n    this.blogVo.viewsStart= viewsStart;\n    this.blogVo.viewsEnd= viewsEnd;\n    blogApi.getBlogByPage(this.page, this.limit, this.blogVo).then(res => {\n        this.blogList = res.data.blogList\n        this.total = res.data.total\n    });\n},\n//每页记录数量改变时间\npageSizeChange(size) {\n    this.limit = size\n    this.getBlogPage()\n},\n//页码改变事件\npageChange(page) {\n    this.page = page\n},\n```\n\n\n\n## 4.分页模板\n\n显示分页信息\n\n```html\n<!--分页方法-->\n<el-pagination\n    :current-page=\"this.page\"\n    :total=\"this.total\"\n    :page-size=\"this.limit\"\n    :page-sizes=\"[5,10,20,50]\"\n    layout=\"sizes, prev, pager, next, jumper, ->, total, slot\"\n    style=\"padding: 20px 0;text-align: center\"\n    background\n    @current-change=\"pageChange\"\n    @size-change=\"pageSizeChange\"\n/>\n```\n\n选择分页内容\n\n```html\n<div>\n    <div align=\"center\">\n        <el-button @click=\"goThis\" type=\"success\" index=\"1-3\">显示所有</el-button>\n        <div v-for=\"blogCategory in blogCategoryList\">\n            <el-button type=\"text\"\n                       @click=\"getBlogPage(null, null,blogCategory.category,null,null ) \">\n                {{ blogCategory.category }}\n            </el-button>\n        </div>\n    </div>\n</div>\n```\n\n\n\n# 三、强制选择博客分类\n\n![image-20200916124342418](https://gitee.com/likeloveC/picture_bed/raw/master/img/8.26/20200916124349.png)', 0, 11, 'like', 'like', 'https://huyaimg.msstatic.com/avatar/1014/39/d0dba41e9a3db25510a8cc3065246c_180_135.jpg?1594368665', 0, 'blog of likelove', '2020-09-16 12:39:45', '2020-09-23 17:42:37', 0, 1);
INSERT INTO `blog` VALUES (69, NULL, '你是', '*我的名字李可*\n我沒有闻花\n我喜欢春娇与志明', 0, 1, 'surblue', 'surblue', 'https://oss.aliyuncs.com/aliyun_id_photo_bucket/default_handsome.jpg', 0, '随笔', '2020-09-16 15:39:14', '2020-09-16 15:39:44', 0, 0);
INSERT INTO `blog` VALUES (70, NULL, 'cloud-01-项目创建', '# 微服务\n\nspringCloud是分布式微服务架构的一站式解决方案，是多种微服务架构落地技术的集合体\n\n![image-20200828211949059](C:%5CUsers%5Cpdd20%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200828211949059.png)\n\n\n\n# 版本选型\n\n![image-20200828213110160](https://gitee.com/likeloveC/picture_bed/raw/master/img/8.26/20200828213110.png)\n\n# 一、父项目创建\n\n## 1.约定 > 配置 > 编码\n\n*   定义jdk 1.8\n\n*   定义文件类型 uft8\n\n*   注解生效\n\n    ![image-20200828214514233](https://gitee.com/likeloveC/picture_bed/raw/master/img/8.26/20200828214514.png)\n\n## 2.父项目Pom依赖\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<project xmlns=\"http://maven.apache.org/POM/4.0.0\"\n         xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n         xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\">\n    <modelVersion>4.0.0</modelVersion>\n    <groupId>com.like.SpringCloud</groupId>\n    <artifactId>parent</artifactId>\n    <version>1.0-SNAPSHOT</version>\n    <!--设置-->\n    <packaging>pom</packaging>\n    <!--统一管理jar包版本-->\n    <properties>\n        <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>\n        <maven.compiler.source>12</maven.compiler.source>\n        <maven.compiler.target>12</maven.compiler.target>\n        <junit.version>4.9</junit.version>\n        <lombok.version>1.18.10</lombok.version>\n        <log4j.version>1.2.9</log4j.version>\n        <mysql.version>5.1.47</mysql.version>\n        <druid.version>1.1.16</druid.version>\n        <mybatis.spring.boot.version>2.1.1</mybatis.spring.boot.version>\n    </properties>\n    <!--声明依赖，并不引入，等待子项目引入-->\n    <dependencyManagement>\n        <dependencies>\n            <dependency>\n                <groupId>org.apache.maven.plugins</groupId>\n                <artifactId>maven-project-info-reports-plugin</artifactId>\n                <version>3.0.0</version>\n            </dependency>\n            <!--spring boot 2.2.2-->\n            <dependency>\n                <groupId>org.springframework.boot</groupId>\n                <artifactId>spring-boot-dependencies</artifactId>\n                <version>2.2.2.RELEASE</version>\n                <type>pom</type>\n                <scope>import</scope>\n            </dependency>\n            <!--spring cloud Hoxton.SR1-->\n            <dependency>\n                <groupId>org.springframework.cloud</groupId>\n                <artifactId>spring-cloud-dependencies</artifactId>\n                <version>Hoxton.SR1</version>\n                <type>pom</type>\n                <scope>import</scope>\n            </dependency>\n            <!--alibaba.cloud-->\n            <dependency>\n                <groupId>com.alibaba.cloud</groupId>\n                <artifactId>spring-cloud-alibaba-dependencies</artifactId>\n                <version>2.1.0.RELEASE</version>\n                <type>pom</type>\n                <scope>import</scope>\n            </dependency>\n            <!-- druid-->\n            <dependency>\n                <groupId>com.alibaba</groupId>\n                <artifactId>druid</artifactId>\n                <version>${druid.version}</version>\n            </dependency>\n            <!--mybatis-->\n            <dependency>\n                <groupId>org.mybatis.spring.boot</groupId>\n                <artifactId>mybatis-spring-boot-starter</artifactId>\n                <version>${mybatis.spring.boot.version}</version>\n            </dependency>\n            <!--mysql-->\n            <dependency>\n                <groupId>mysql</groupId>\n                <artifactId>mysql-connector-java</artifactId>\n                <version>${mysql.version}</version>\n                <scope>runtime</scope>\n            </dependency>\n            <!--junit-->\n            <dependency>\n                <groupId>junit</groupId>\n                <artifactId>junit</artifactId>\n                <version>${junit.version}</version>\n            </dependency>\n            <!--log4j-->\n            <dependency>\n                <groupId>log4j</groupId>\n                <artifactId>log4j</artifactId>\n                <version>${log4j.version}</version>\n            </dependency>\n        </dependencies>\n    </dependencyManagement>\n    <repositories>\n        <repository>\n            <id>aliyun</id>\n            <name>aliyun</name>\n            <layout>default</layout>\n            <url>https://maven.aliyun.com/repository/public/</url>\n            <snapshots>\n                <enabled>true</enabled>\n            </snapshots>\n            <releases>\n                <enabled>true</enabled>\n            </releases>\n        </repository>\n    </repositories>\n</project>\n```\n\n# 二、payment8001项目创建\n\n## ==构建思路==：\n\n支付项目\n\n功能：\n\n1.  根据id查询payment\n2.  提交payment到数据库\n\n项目结构：\n\n![image-20200830113920637](https://gitee.com/likeloveC/picture_bed/raw/master/img/8.26/20200830113927.png)\n\n## 1.依赖\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<project xmlns=\"http://maven.apache.org/POM/4.0.0\"\n         xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n         xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\">\n    <parent>\n        <artifactId>SpringCloud</artifactId>\n        <groupId>com.like</groupId>\n        <version>0.0.1-SNAPSHOT</version>\n    </parent>\n    <modelVersion>4.0.0</modelVersion>\n\n    <artifactId>cloud-provider-payment8001</artifactId>\n\n    <dependencies>\n      <!--  &lt;!&ndash;包含了sleuth+zipkin&ndash;&gt;\n        <dependency>\n            <groupId>org.springframework.cloud</groupId>\n            <artifactId>spring-cloud-starter-zipkin</artifactId>\n        </dependency>\n        &lt;!&ndash;eureka-client&ndash;&gt;\n        <dependency>\n            <groupId>org.springframework.cloud</groupId>\n            <artifactId>spring-cloud-starter-netflix-eureka-client</artifactId>\n        </dependency>\n        <dependency>&lt;!&ndash; 引入自己定义的api通用包，可以使用Payment支付Entity &ndash;&gt;\n            <groupId>com.atguigu.springcloud</groupId>\n            <artifactId>cloud-api-commons</artifactId>\n            <version>${project.version}</version>\n        </dependency>-->\n        <!--web-->\n        <dependency>\n            <groupId>org.springframework.boot</groupId>\n            <artifactId>spring-boot-starter-web</artifactId>\n        </dependency>\n        <!--actuator-->\n        <dependency>\n            <groupId>org.springframework.boot</groupId>\n            <artifactId>spring-boot-starter-actuator</artifactId>\n        </dependency>\n        <!--mybatis-plus-boot-starter-->\n      <dependency>\n         <groupId>com.baomidou</groupId>\n         <artifactId>mybatis-plus-boot-starter</artifactId>\n      </dependency>\n        <dependency>\n            <groupId>com.alibaba</groupId>\n            <artifactId>druid-spring-boot-starter</artifactId>\n            <version>1.1.10</version>\n        </dependency>\n        <!--mysql-connector-java-->\n        <dependency>\n            <groupId>mysql</groupId>\n            <artifactId>mysql-connector-java</artifactId>\n        </dependency>\n        <!--jdbc-->\n        <dependency>\n            <groupId>org.springframework.boot</groupId>\n            <artifactId>spring-boot-starter-jdbc</artifactId>\n        </dependency>\n        <!--热部署-->\n        <dependency>\n            <groupId>org.springframework.boot</groupId>\n            <artifactId>spring-boot-devtools</artifactId>\n            <scope>runtime</scope>\n            <optional>true</optional>\n        </dependency>\n        <!--lombok-->\n        <dependency>\n            <groupId>org.projectlombok</groupId>\n            <artifactId>lombok</artifactId>\n            <optional>true</optional>\n        </dependency>\n        <!--test-->\n        <dependency>\n            <groupId>org.springframework.boot</groupId>\n            <artifactId>spring-boot-starter-test</artifactId>\n            <scope>test</scope>\n        </dependency>\n    </dependencies>\n\n</project>\n\n```\n\n\n\n## 2.资源文件配置.yml\n\n```yaml\nserver:\n  port: 8001\n\nspring:\n  application:\n    name: cloud-payment-service\n  sleuth:\n    sampler:\n    #采样率值介于 0 到 1 之间，1 则表示全部采集\n    probability: 1\n  datasource:\n    type: com.alibaba.druid.pool.DruidDataSource            # 当前数据源操作类型\n    driver-class-name: com.mysql.jdbc.Driver          # mysql驱动包\n    url: jdbc:mysql://localhost:3306/springcloud?serverTimezone=UTC\n    username: root\n    password: rootroot\n\n\n\n```\n\n\n\n## 3.启动类\n\n```java\npackage com.lk.sc;\n\n@SpringBootApplication\n@ComponentScan(\"com.lk.sc.*\")\npublic class CloudPayment8001 {\n    public static void main(String[] args) {\n        SpringApplication.run(CloudPayment8001.class,args);\n    }\n}\n```\n\n\n\n\n\n## 4.实体类\n\n### 	a.payment\n\n```java\npackage com.lk.sc.entity;\n@Data\npublic class Payment implements Serializable {\n    private Long id;\n    private String serial;\n}\n```\n\n\n\n\n\n### 	b.定义一个统一的返回结果集类\n\n\n\n```java\npackage com.lk.sc.entity;\n\n@Data\npublic class Result {\n    private Boolean success;\n    private Integer code;\n    private String message;\n    private Map<String, Object> data = new HashMap<String, Object>();\n    public Result() {\n    }\n    public static Result ok() {\n        Result result = new Result();\n        result.setSuccess(ResultCodeEnum.SUCCESS.getSuccess());\n        result.setCode(ResultCodeEnum.SUCCESS.getCode());\n        result.setMessage(ResultCodeEnum.SUCCESS.getMessage());\n        return result;\n    }\n    public static Result error() {\n        Result result = new Result();\n        result.setSuccess(ResultCodeEnum.UNKNOWN_REASON.getSuccess());\n        result.setCode(ResultCodeEnum.UNKNOWN_REASON.getCode());\n        result.setMessage(ResultCodeEnum.UNKNOWN_REASON.getMessage());\n        return result;\n    }\n    public Result success(Boolean success) {\n        this.setSuccess(success);\n        return this;\n    }\n    public Result message(String message) {\n        this.setMessage(message);\n        return this;\n    }\n    public Result code(Integer code) {\n        this.setCode(code);\n        return this;\n    }\n    public Result data(String key, Object value) {\n        this.data.put(key, value);\n        return this;\n    }\n    public Result data(Map<String, Object> map) {\n        this.setData(map);\n        return this;\n    }\n    @Getter\n    @ToString\n    enum ResultCodeEnum {\n        /**\n         * 成功\n         */\n        SUCCESS(true, 20000, \"成功\"),\n        /**\n         * 失败\n         */\n        UNKNOWN_REASON(false, 20001, \"未知错误\");\n        private Boolean success;\n        private Integer code;\n        private String message;\n        ResultCodeEnum(Boolean success, Integer code, String message) {\n            this.success = success;\n            this.code = code;\n            this.message = message;\n        }\n    }\n}\n```\n\n\n\n## 5.dao层\n\n### 	a.接口\n\n```java\npackage com.lk.sc.mapper;\n\n@Mapper\n@Repository\npublic interface PaymentMapper  extends BaseMapper<Payment> {\n\n}\n```\n\n\n\n### 	b.配置文件\n\n```xml\npackage com.lk.sc.mapper.xml;\n\n<?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n<!DOCTYPE mapper\n        PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\"\n        \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\">\n<mapper namespace=\"com.lk.sc.mapper.PaymentMapper\">\n\n</mapper>\n```\n\n\n\n## 6.service层\n\n### 	a.接口\n\n继承IService类\n\n```java\npackage com.lk.sc.service;\npublic interface PaymentService  extends IService<Payment> {\n\n}\n```\n\n​	\n\n### 	b.实现\n\n继承ServiceImpl类，实现 PaymentService\n\n```java\npackage com.lk.sc.service.impl;\n@Service\npublic class PaymentServiceImpl extends ServiceImpl<PaymentMapper, Payment> implements PaymentService {\n\n}\n```\n\n\n\n## 7.controller层\n\n\n\n```java\npackage com.lk.sc.controller;\n\n@RequestMapping(\"/payment\")\n@RestController\npublic class PaymentController {\n\n    @Resource\n    PaymentService paymentService;\n\n    /**\n     * 根据id获取payment\n     *\n     * @param id 需要查询的payment对象的id\n     * @return Result.data\n     */\n    @GetMapping(\"/get/{id}\")\n    public Result getById(@PathVariable String id) {\n        Payment paymentServiceById = paymentService.getById(id);\n        if (paymentServiceById != null) {\n            return Result.ok().data(\"payment\", paymentServiceById).message(\"查询成功\");\n        }\n        return Result.error().message(\"查询失败，查询id:\"+id);\n    }\n\n    /**\n     * 添加payment到数据库\n     *\n     * @param payment 需要添加的payment\n     * @return Result\n     */\n    @PostMapping(\"/save\")\n    public Result save(Payment payment) {\n        boolean save = paymentService.save(payment);\n        if (save) {\n            return Result.ok().success(save).message(\"保存成功\");\n        }\n        return Result.error().message(\"保存失败，数据库中可能已经存在这个对象,保存对象:\"+payment);\n    }\n}\n```\n\n\n\n## 8.config\n\n```java\npackage com.lk.sc.config;\n\n/**\n * @author likeLove\n * @time 2020-08-30  11:23\n */\n@Configuration\npublic class MybatisPlusConfig {\n    @Bean\n    public MapperScannerConfigurer mapperScannerConfigurer() {\n        MapperScannerConfigurer scannerConfigurer = new MapperScannerConfigurer();\n        //可以通过环境变量获取你的mapper路径,这样mapper扫描可以通过配置文件配置了\n        scannerConfigurer.setBasePackage(\"com.lk.*.mapper\");\n        return scannerConfigurer;\n    }\n}\n```\n\n\n\n## 9.建表sql\n\n~~~sql\nSET NAMES utf8mb4;\nSET FOREIGN_KEY_CHECKS = 0;\n\n-- ----------------------------\n-- Table structure for payment\n-- ----------------------------\nDROP TABLE IF EXISTS `payment`;\nCREATE TABLE `payment`  (\n  `id` bigint(20) NOT NULL AUTO_INCREMENT COMMENT \'主键\',\n  `serial` varchar(200) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL COMMENT \'支付流水号\',\n  PRIMARY KEY (`id`) USING BTREE\n) ENGINE = InnoDB AUTO_INCREMENT = 36 CHARACTER SET = utf8 COLLATE = utf8_general_ci COMMENT = \'支付表\' ROW_FORMAT = DYNAMIC;\n\n-- ----------------------------\n-- Records of payment\n-- ----------------------------\nINSERT INTO `payment` VALUES (31, \'尚硅谷111\');\nINSERT INTO `payment` VALUES (32, \'atguigu002\');\nINSERT INTO `payment` VALUES (34, \'atguigu002\');\nINSERT INTO `payment` VALUES (35, \'atguigu002\');\n\nSET FOREIGN_KEY_CHECKS = 1;\n~~~\n\n\n\n## 10.==小结==\n\n### 1.在运行的时候出现 `Invalid bound statement (not found)` 异常了\n\n~~~\nInvalid bound statement (not found): \n	com.lk.sc.service.PaymentService.getBaseMapper\norg.apache.ibatis.binding.BindingException: \n	Invalid bound statement (not found): \n		com.lk.sc.service.PaymentService.getBaseMapper\n~~~\n\n这是因为没有配置mapper扫描的结果，解决：添加mybatisconfig类，\n\n*   方法一：在 `Configuration` 类上使用注解 `MapperScan`\n\n*   方法二：在`Configuration`类中添加mapper扫描bean\n\n    ```java\n    @Bean\n    public MapperScannerConfigurer mapperScannerConfigurer(){\n        MapperScannerConfigurer scannerConfigurer = new MapperScannerConfigurer();\n        //可以通过环境变量获取你的mapper路径,这样mapper扫描可以通过配置文件配置了\n        scannerConfigurer.setBasePackage(\"com.yourpackage.*.mapper\");\n        return scannerConfigurer;\n    }\n    ```\n\n\n\n总之：查看官网你一定会找到你想要的\n\n\n\n# 三、api-common项目创建\n\n## 目的：\n\n*   抽取一些公共的方法和资源\n\n\n\n## 1.pom依赖\n\n```xml\n<dependencies>\n    <!--热部署-->\n    <dependency>\n        <groupId>org.springframework.boot</groupId>\n        <artifactId>spring-boot-devtools</artifactId>\n        <scope>runtime</scope>\n        <optional>true</optional>\n    </dependency>\n    <!--lombok-->\n    <dependency>\n        <groupId>org.projectlombok</groupId>\n        <artifactId>lombok</artifactId>\n    </dependency>\n    <!--hutool工具-->\n    <dependency>\n        <groupId>cn.hutool</groupId>\n        <artifactId>hutool-all</artifactId>\n        <version>5.1.0</version>\n    </dependency>\n    <!--mybatis-->\n    <dependency>\n        <groupId>com.baomidou</groupId>\n        <artifactId>mybatis-plus-boot-starter</artifactId>\n    </dependency>\n    <!--test-->\n    <dependency>\n        <groupId>org.springframework.boot</groupId>\n        <artifactId>spring-boot-starter-test</artifactId>\n        <scope>test</scope>\n    </dependency>\n</dependencies>\n```\n\n\n\n## 2.引入实体类\n\n![image-20200831122957244](https://gitee.com/likeloveC/picture_bed/raw/master/img/8.26/20200831122957.png)\n\n\n\n## 3.在其他的项目中引入这个公共的api项目\n\n```xml\n<!--引入自己定义的api-->\n<dependency>\n    <groupId>com.like</groupId>\n    <artifactId>cloud-api-common</artifactId>\n    <version>${project.version}</version>\n</dependency>\n```\n\n\n\n\n\n\n\n# 四、order80项目创建\n\n## 1.目的：\n\n模拟用户操作，远程调用payment8001中的创建和查询方法\n\n\n\n![](https://gitee.com/likeloveC/picture_bed/raw/master/img/8.26/20200831123619.png)\n\n## 2.实现方法：\n\n通过RestTemplate远程调用\n\n## 3.pom依赖\n\n```xml\n<dependencies>\n    <!--引入自己定义的api-->\n    <dependency>\n        <groupId>com.like</groupId>\n        <artifactId>cloud-api-common</artifactId>\n        <version>${project.version}</version>\n    </dependency>\n    <dependency>\n        <groupId>org.springframework.boot</groupId>\n        <artifactId>spring-boot-starter-web</artifactId>\n    </dependency>\n    <dependency>\n        <groupId>org.springframework.boot</groupId>\n        <artifactId>spring-boot-starter-actuator</artifactId>\n    </dependency>\n</dependencies>\n```\n\n## 4.启动类\n\n```java\n@SpringBootApplication(exclude = DataSourceAutoConfiguration.class)\npublic class CloudOrder80 {\n    public static void main(String[] args) {\n        SpringApplication.run(CloudOrder80.class,args);\n    }\n}\n```\n\n\n\n## 5.配置文件.yml\n\n```yml\nserver:\n  port: 80\n```\n\n\n\n## 6.定义resttemplate配置类\n\n返回resttemplate对象\n\n```java\n@Configuration\npublic class RestTemplateConfig {\n    @Bean\n    public RestTemplate getRestTemplate() {\n        return new RestTemplate();\n    }\n}\n```\n\n\n\n## 7.定义ordercontroller\n\n```java\n@RestController\n@RequestMapping(\"/consumer\")\npublic class OrderController {\n    @Autowired\n    RestTemplate restTemplate;\n\n    public static final String PAYMENT_URL = \"http://localhost:8001\";\n\n    @PostMapping(\"/payment/save\")\n    public Result savePayment( Payment payment) {\n        System.out.println(payment);\n        return restTemplate.postForObject(PAYMENT_URL + \"/payment/save\", payment, Result.class);\n    }\n\n    @GetMapping(\"/payment/get/{id}\")\n    public Result getPayment(@PathVariable(\"id\") Long id) {\n        return restTemplate.getForObject(PAYMENT_URL + \"/payment/get/\" + id, Result.class);\n    }\n}\n```\n\n\n\n## 8.==注意==\n\n1.在==远程调用save方法的时候可能会出现payment对象为null==的情况，但是直接调用paymentcontroller里面的save方法payment不会为null\n\n在paymentcontroller中的save方法中为payment加上`@requestboot注解`,但是加了这个注解后，直接调用paymentcontroller中的save又会出现payment为null的情况\n\n\n\n2.因为在api-common中==引入了mybatis-plus包，==所以要在启动类中添加排除类，排除==数据源自动配置类==\n\n```java\n@SpringBootApplication(exclude = DataSourceAutoConfiguration.class)\n```', 1, 0, 'like', 'like', 'https://huyaimg.msstatic.com/avatar/1014/39/d0dba41e9a3db25510a8cc3065246c_180_135.jpg?1594368665', 0, 'SpringCloud', '2020-09-16 18:41:41', '2020-09-16 18:41:41', 0, 0);
INSERT INTO `blog` VALUES (71, NULL, 'cloud-02-微服务初级', '\n\n![image-20200901204250401](C:%5CUsers%5Cpdd20%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200901204250789.png)一、微服务注册中心-eureka\n\n**服务治理**\n\nspring cloud 封装的 Netflix 公司开发的 eureka 模块实现 ==服务治理==\n\n在传统的RPC远程调用框架中，管理每个服务和服务之间的依赖关系比较复杂，所以需要服务治理\n\n\n\n**服务注册**\n\n![image-20200831125443965](https://gitee.com/likeloveC/picture_bed/raw/master/img/8.26/20200831125444.png)\n\n\n\n## 服务中心\n\n![image-20200831125635774](https://gitee.com/likeloveC/picture_bed/raw/master/img/8.26/20200831125635.png)\n\n\n\n## 注册中心\n\n![image-20200831125645361](https://gitee.com/likeloveC/picture_bed/raw/master/img/8.26/20200831125645.png)\n\n\n\n## 1.Eureka7001服务器项目创建\n\n![image-20200831133138291](https://gitee.com/likeloveC/picture_bed/raw/master/img/8.26/20200831133138.png)\n\n### a.pom依赖\n\n```xml\n<dependencies>\n    <!--自己定义的通用api-->\n    <dependency>\n        <groupId>com.like</groupId>\n        <artifactId>cloud-api-common</artifactId>\n        <version>${project.version}</version>\n    </dependency>\n    <!--eureka-server-->\n    <dependency>\n        <groupId>org.springframework.cloud</groupId>\n        <artifactId>spring-cloud-starter-netflix-eureka-server</artifactId>\n    </dependency>\n    <!--boot web actuator-->\n    <dependency>\n        <groupId>org.springframework.boot</groupId>\n        <artifactId>spring-boot-starter-web</artifactId>\n    </dependency>\n    <dependency>\n        <groupId>org.springframework.boot</groupId>\n        <artifactId>spring-boot-starter-actuator</artifactId>\n    </dependency>\n    <dependency>\n        <groupId>org.springframework.boot</groupId>\n        <artifactId>spring-boot-devtools</artifactId>\n        <scope>runtime</scope>\n        <optional>true</optional>\n    </dependency>\n</dependencies>\n```\n\n\n\n### b.配置文件\n\n```yml\nserver:\n  port: 7001\n\nspring:\n  application:\n    name: cloud-eureka-server\n\neureka:\n  instance:\n    hostname: eureka7001.com #eureka服务端的实例名称\n  client:\n    register-with-eureka: false     #false表示不向注册中心注册自己。\n    fetch-registry: false     #false表示自己端就是注册中心，我的职责就是维护服务实例，并不需要去检索服务\n    service-url:\n      #集群指向其它eureka\n      #defaultZone: http://eureka7002.com:7002/eureka/\n      #单机就是7001自己\n      defaultZone: http://eureka7001.com:7001/eureka/\n    #server:\n    #关闭自我保护机制，保证不可用服务被及时踢除\n    #enable-self-preservation: false\n    #eviction-interval-timer-in-ms: 2000\n```\n\n\n\n### c.启动类\n\n```java\n@SpringBootApplication(exclude = DataSourceAutoConfiguration.class)\n@EnableEurekaServer\npublic class CloudEureka7001 {\n    public static void main(String[] args) {\n        SpringApplication.run(CloudEureka7001.class,args);\n    }\n}\n```\n\n\n\n## 2.将payment和order注册到eureka服务器上去\n\n### 1.引入erueka.client依赖\n\n```xml\n<!--eureka-client-->\n<dependency>\n    <groupId>org.springframework.cloud</groupId>\n    <artifactId>spring-cloud-starter-netflix-eureka-client</artifactId>\n</dependency>\n```\n\n### 2.添加配置文件\n\n```yml\neureka:\n  client:\n    #表示是否将自己注册进EurekaServer默认为true。\n    register-with-eureka: true\n    #是否从EurekaServer抓取已有的注册信息，默认为true。单节点无所谓，集群必须设置为true才能配合ribbon使用负载均衡\n    fetchRegistry: true\n    service-url:\n      #单机版\n      defaultZone: http://localhost:7001/eureka\n      # 集群版\n      #defaultZone: http://eureka7001.com:7001/eureka,http://eureka7002.com:7002/eureka\n  instance:\n    instance-id: payment8001\n    #访问路径可以显示IP地址\n    prefer-ip-address: true\n    #Eureka客户端向服务端发送心跳的时间间隔，单位为秒(默认是30秒)\n    #lease-renewal-interval-in-seconds: 1\n    #Eureka服务端在收到最后一次心跳后等待时间上限，单位为秒(默认是90秒)，超时将剔除服务\n    #lease-expiration-duration-in-seconds: 2\n```\n\n### 3.在启动类上添加注解\n\n```java\n@EnableEurekaClient\n```\n\n\n\n### 4.order同上\n\n\n\n### 5.测试\n\n![image-20200831133639206](https://gitee.com/likeloveC/picture_bed/raw/master/img/8.26/20200831133639.png)\n\n\n\n\n\n## 3.搭建eureka集群\n\n![image-20200831140609159](https://gitee.com/likeloveC/picture_bed/raw/master/img/8.26/20200831140609.png)\n\n![image-20200831140749443](https://gitee.com/likeloveC/picture_bed/raw/master/img/8.26/20200831140749.png)\n\n\n\n### a.创建Eruekaserver7002项目\n\n#### 	1.pom依赖和7001一样\n\n#### 	2.配置文件\n\n```yml\nserver:\n  port: 7002\n\nspring:\n  application:\n    name: cloud-eureka-server\n\neureka:\n  instance:\n    hostname: eureka7002.com #eureka服务端的实例名称\n  client:\n    register-with-eureka: false     #false表示不向注册中心注册自己。\n    fetch-registry: false     #false表示自己端就是注册中心，我的职责就是维护服务实例，并不需要去检索服务\n    service-url:\n      #集群指向其它eureka\n      #defaultZone: http://eureka7002.com:7002/eureka/\n      #单机就是7001自己\n      defaultZone: http://eureka7001.com:7001/eureka/\n    #server:\n    #关闭自我保护机制，保证不可用服务被及时踢除\n    #enable-self-preservation: false\n    #eviction-interval-timer-in-ms: 2000\n```\n\n#### 3.启动类\n\n同7001\n\n\n\n#### 4.修改hosts文件\n\n![image-20200831143303035](https://gitee.com/likeloveC/picture_bed/raw/master/img/8.26/20200831143303.png)\n\n#### 5.测试\n\n![image-20200831143319553](https://gitee.com/likeloveC/picture_bed/raw/master/img/8.26/20200831143319.png)![image-20200831143326450](https://gitee.com/likeloveC/picture_bed/raw/master/img/8.26/20200831143326.png)\n\n\n\n### b.把payment和order注册到eureka上面去\n\n把appliation.yml中的eureka.client.service.url.defaultZone修改为\n\n```yml\ndefaultZone: http://eureka7001.com:7001/eureka,http://eureka7002.com:7002/eureka\n```\n\n\n\n测试：\n\n![image-20200831143551642](https://gitee.com/likeloveC/picture_bed/raw/master/img/8.26/20200831143551.png)\n\n![image-20200831143559843](https://gitee.com/likeloveC/picture_bed/raw/master/img/8.26/20200831143559.png)\n\n\n\n\n\n![image-20200831143610824](https://gitee.com/likeloveC/picture_bed/raw/master/img/8.26/20200831143610.png)\n\n\n\n## 4.搭建payment集群\n\n### 	创建payment8002项目\n\n*   复制payment8001，修改端口号为8002\n\n*   在order项目中RestTemplateConfig的getRestTemplate方法上加注解\n\n    ```java\n    @Configuration\n    public class RestTemplateConfig {\n    \n        @Bean\n        @LoadBalanced\n        public RestTemplate getRestTemplate() {\n            return new RestTemplate();\n        }\n    }\n    ```\n\n*   在payment8001和payment8002项目的controller中加入serverPort字段\n\n    完成请求时，一起返回这个字段\n\n    ```java\n    @Value(\"${server.port}\")\n    String serverPort;\n    ```\n\n*   把OrderController中的payment_url修改为微服务的名字\n\n    ```java\n    @RestController\n    @RequestMapping(\"/consumer\")\n    public class OrderController {\n        @Autowired\n        RestTemplate restTemplate;\n    \n        //public static final String PAYMENT_URL = \"http://localhost:8001\";\n        public static final String PAYMENT_URL = \"http://CLOUD-PAYMENT-SERVICE\";\n        \n        ···\n    ```\n\n\n\n### 测试：\n\n![image-20200831150527847](https://gitee.com/likeloveC/picture_bed/raw/master/img/8.26/20200831150527.png)\n\n![image-20200831150541175](https://gitee.com/likeloveC/picture_bed/raw/master/img/8.26/20200831150541.png)\n\n\n\n\n\n### ==总结==\n\n不加 @LoadBalanced这个注解在RestTemplate会报错，加了就会轮询访问- ==ribbon的负载均衡==\n\nribbon和eureka整合后，consumer可以直接调用服务，而不用关心地址和端口号，并实现了负载均衡的功能\n\n\n\n\n\n## 5.服务发现 Discovery	\n\n对于注册eureka里面的微服务，可以通过服务发现来获得该服务的信息\n\n\n\n1.  在启动类上添加==@EnableDiscoveryClient==注解\n\n2.  在paymentController中注入\n\n    ```java\n    @Resource\n    DiscoveryClient discoveryClient;\n    ```\n\n3.  添加方法\n\n    ```java\n    @GetMapping(\"/discovery\")\n    public Object getDiscoveryInfo() {\n        List<String> services = discoveryClient.getServices();\n        for (String element : services) {\n            log.info(\"*****element: \" + element);\n        }\n        List<ServiceInstance> instances = discoveryClient.getInstances(\"CLOUD-PAYMENT-SERVICE\");\n        for (ServiceInstance instance : instances) {\n            log.info(instance.getServiceId() + \"\\t\" + instance.getHost() + \"\\t\" + instance.getPort() + \"\\t\" + instance.getUri());\n        }\n        return this.discoveryClient;\n    }\n    ```\n\n![](https://gitee.com/likeloveC/picture_bed/raw/master/img/8.26/20200831160306.png)\n\n\n\n\n\n## 6.eureka的自我保护\n\n某时刻一个微服务不能用了，eureka不会立刻清理，依旧会对该微服务的信息进行保存，属于cap里面的ap分支\n\n![image-20200831160346958](https://gitee.com/likeloveC/picture_bed/raw/master/img/8.26/20200831160347.png)\n\n\n\n![image-20200831160818482](https://gitee.com/likeloveC/picture_bed/raw/master/img/8.26/20200831160818.png)\n\n![image-20200831160902693](https://gitee.com/likeloveC/picture_bed/raw/master/img/8.26/20200831160902.png)\n\n\n\n### 关闭自我保护\n\n\n\neureka7001\n\n```yml\neureka:\n  instance:\n    hostname: eureka7001.com #eureka服务端的实例名称\n  client:\n    register-with-eureka: false     #false表示不向注册中心注册自己。\n    fetch-registry: false     #false表示自己端就是注册中心，我的职责就是维护服务实例，并不需要去检索服务\n    service-url:\n      #集群指向其它eureka\n      defaultZone: http://eureka7002.com:7002/eureka/\n      #单机就是7001自己\n      #defaultZone: http://eureka7001.com:7001/eureka/\n    #server:\n    #关闭自我保护机制，保证不可用服务被及时踢除\n    #enable-self-preservation: false\n    #eviction-interval-timer-in-ms: 2000\n```\n\n\n\npayment8001\n\n```yml\neureka:\n  client:\n    #表示是否将自己注册进EurekaServer默认为true。\n    register-with-eureka: true\n    #是否从EurekaServer抓取已有的注册信息，默认为true。单节点无所谓，集群必须设置为true才能配合ribbon使用负载均衡\n    fetchRegistry: true\n    service-url:\n      #单机版\n      #defaultZone: http://localhost:7001/eureka\n      # 集群版\n      defaultZone: http://eureka7001.com:7001/eureka,http://eureka7002.com:7002/eureka\n  instance:\n    instance-id: payment8001\n    #访问路径可以显示IP地址\n    prefer-ip-address: true\n    #Eureka客户端向服务端发送心跳的时间间隔，单位为秒(默认是30秒)\n    #lease-renewal-interval-in-seconds: 1\n    #Eureka服务端在收到最后一次心跳后等待时间上限，单位为秒(默认是90秒)，超时将剔除服务\n    #lease-expiration-duration-in-seconds: 2\n```\n\n\n\n## 7. zookeeper\n\nzookeeper是一个分布式协调工具，可以实现注册中心功能\n\n1.payment8004项目创建\n\n### 1.pom依赖\n\n~~~xml\n<dependencies>\n        <!-- SpringBoot整合Web组件 -->\n        <dependency>\n            <groupId>org.springframework.boot</groupId>\n            <artifactId>spring-boot-starter-web</artifactId>\n        </dependency>\n        <dependency><!-- 引入自己定义的api通用包，可以使用Payment支付Entity -->\n            <groupId>com.atguigu.springcloud</groupId>\n            <artifactId>cloud-api-commons</artifactId>\n            <version>${project.version}</version>\n        </dependency>\n        <!-- SpringBoot整合zookeeper客户端 -->\n        <dependency>\n            <groupId>org.springframework.cloud</groupId>\n            <artifactId>spring-cloud-starter-zookeeper-discovery</artifactId>\n            <!--先排除自带的zookeeper3.5.3-->\n            <exclusions>\n                <exclusion>\n                    <groupId>org.apache.zookeeper</groupId>\n                    <artifactId>zookeeper</artifactId>\n                </exclusion>\n            </exclusions>\n        </dependency>\n        <!--添加zookeeper3.4.9版本-->\n        <dependency>\n            <groupId>org.apache.zookeeper</groupId>\n            <artifactId>zookeeper</artifactId>\n            <version>3.4.9</version>\n        </dependency>\n        <dependency>\n            <groupId>org.springframework.boot</groupId>\n            <artifactId>spring-boot-devtools</artifactId>\n            <scope>runtime</scope>\n            <optional>true</optional>\n        </dependency>\n        <dependency>\n            <groupId>org.projectlombok</groupId>\n            <artifactId>lombok</artifactId>\n            <optional>true</optional>\n        </dependency>\n        <dependency>\n            <groupId>org.springframework.boot</groupId>\n            <artifactId>spring-boot-starter-test</artifactId>\n            <scope>test</scope>\n        </dependency>\n    </dependencies>\n~~~\n\n\n\n### 2.配置文件.yml\n\n![image-20200831164341271](https://gitee.com/likeloveC/picture_bed/raw/master/img/8.26/20200831164341.png)\n\n\n\n### 3.启动类\n\n### 4.controller\n\n![image-20200831164626891](https://gitee.com/likeloveC/picture_bed/raw/master/img/8.26/20200831164627.png)\n\n\n\n\n\n# 二、服务调用-Ribbon\n\n**概述：**\n\nspring cloud ribbon 是一套实现负载均衡的工具，主要功能提供==客户端软件负载均衡算法和服务调用==，ribbon客户端组件提供一系列完善的配置项如连接超时，重试。简单来说就是在配置文件中列出==load banlancer(LB)==后面所有的机器，==ribbon会自动帮助你基于某种规则(简单轮询，随机连接)==去连接这些机器，	\n\n## **1.作用：**\n\n负载均衡+RestTemplate调用\n\n![image-20200831171141144](https://gitee.com/likeloveC/picture_bed/raw/master/img/8.26/20200831171141.png)\n\n\n\n## **2.工作方式：**\n\n*   先选择EurekaServer，优先选择在同一个区域内负载较少的server\n*   根据用户指定的策略，从sercer取到的服务注册列表中选择一个地址\n*   轮询，随机，根据响应时间加权\n\n\n\n\n\n## 3.irule\n\n==各种规则：==\n\n![image-20200831182916054](https://gitee.com/likeloveC/picture_bed/raw/master/img/8.26/20200831182916.png)\n\n\n\n![image-20200831191528654](https://gitee.com/likeloveC/picture_bed/raw/master/img/8.26/20200831191528.png)\n\n\n\n\n\n### a.切换访问规则\n\n![image-20200831185733643](https://gitee.com/likeloveC/picture_bed/raw/master/img/8.26/20200831185733.png)\n\n```java\n@Configuration\npublic class MyRule {\n    /**\n     * 定义为随机规则  new RandomRule()\n     * @return\n     */\n    @Bean\n    public IRule getIRule() {\n        return new RandomRule();\n    }\n}\n```\n\n\n\n>   在启动类上添加注解\n\n​	@RibbonClient(name = \"CLOUD-PAYMENT-SERVICE\",configuration = MyRule.class)\n\n![image-20200831185813444](https://gitee.com/likeloveC/picture_bed/raw/master/img/8.26/20200831185813.png)\n\n\n\n==注意：==\n\n自定义访问规则类不能和启动类在同一个包里面\n\n\n\n\n\n## 4.负载均衡算法\n\n### a.轮询算法原理\n\nrest接口第几次请求数%服务器集群总数量 = 实际调用服务器位置下表，每次服务重启后rest接口计数从1开始\n\n核心：取余算法\n\n![image-20200831191103550](https://gitee.com/likeloveC/picture_bed/raw/master/img/8.26/20200831191103.png)\n\n\n\n### b.手写一个轮询算法\n\n#### 1.在restTemplate中注释注解\n\n![image-20200831202537885](https://gitee.com/likeloveC/picture_bed/raw/master/img/8.26/20200831202537.png)\n\n\n\n#### 2.定义接口\n\n```java\npublic interface LoadBalancer {\n\n    ServiceInstance instances(List<ServiceInstance> serviceInstances);\n}\n```\n\n\n\n#### 3.实现接口\n\n>   ==int getAndIncrement() ：==\n>\n>   目的next +1 \n>\n>   ==ServiceInstance instances(List<ServiceInstance> serviceInstances);==\n>\n>   取余算法，取出要执行的service实例\n\n```java\n@Component\npublic class MyLoadBalancer implements LoadBalancer {\n\n    private  AtomicInteger atomicInteger = new AtomicInteger(0);\n    public final int getAndIncrement() {\n        int curr;\n        int next;\n        do {\n            curr = this.atomicInteger.get();\n            next = curr >= Integer.MAX_VALUE ? 0 : curr + 1;\n        } while (!this.atomicInteger.compareAndSet(curr, next));\n        System.out.println(\"第几次访问，次数：\" + next);\n        return next;\n    }\n\n    @Override\n    public ServiceInstance instances(List<ServiceInstance> serviceInstances) {\n        int index = getAndIncrement() % serviceInstances.size();\n        return serviceInstances.get(index);\n    }\n}\n```\n\n\n\n4.controller实现方法\n\n```java\n@GetMapping(\"/payment/lb\")\npublic String getPaymentLb() {\n    List<ServiceInstance> instances = discoveryClient.getInstances(\"CLOUD-PAYMENT-SERVICE\");\n    //检查是否为空\n    if (instances == null || instances.size() == 0) {\n        return null;\n    }\n    ServiceInstance serviceInstance = loadBalancer.instances(instances);\n    URI uri = serviceInstance.getUri();\n    return restTemplate.getForObject(uri  + \"/payment/lb\", String.class);\n}\n```\n\n\n\n# 三、服务调用-OpenFeign\n\n是一个声明式的WebService客户端，使用Feign能让编写webservice客户端更简单，使用方法是：==定义一个服务接口然后在上面添加注解==。也支持可插拔式的编码器和解码器。springcloud对feign进行了封装，使其支持了springmvc标准注解库和HttpMessageConverters。可以和Eureka和Ribbon组合使用以支持负载均衡\n\n![image-20200901173035128](https://gitee.com/likeloveC/picture_bed/raw/master/img/8.26/20200901173042.png)\n\n​	\n\n## 1.order引入OpenFeign\n\n### 项目结构\n\n![image-20200901193113332](https://gitee.com/likeloveC/picture_bed/raw/master/img/8.26/20200901193113.png)\n\n### 1.pom依赖\n\n在原来的order80基础上加入\n\n```xml\n<dependency>\n    <groupId>org.springframework.cloud</groupId>\n    <artifactId>spring-cloud-starter-openfeign</artifactId>\n</dependency>\n```\n\n\n\n### 2.yml配置文件\n\n```yaml\nserver:\n  port: 80\nspring:\n  application:\n    name: CLOUD-ORDER-SERVICE\n\neureka:\n  instance:\n    instance-id: orderfeign80\n  client:\n    #表示是否将自己注册进EurekaServer默认为true。\n    #register-with-eureka: true\n    #是否从EurekaServer抓取已有的注册信息，默认为true。单节点无所谓，集群必须设置为true才能配合ribbon使用负载均衡\n    #fetchRegistry: true\n    service-url:\n      #单机版\n      #defaultZone: http://localhost:7001/eureka\n      # 集群版\n      defaultZone: http://eureka7001.com:7001/eureka,http://eureka7002.com:7002/eureka\n```\n\n\n\n### 3.启动类\n\n```java\n@SpringBootApplication(exclude = DataSourceAutoConfiguration.class)\n@EnableFeignClients\npublic class CloudOpenFeignOrder80 {\n    public static void main(String[] args) {\n        SpringApplication.run(CloudOpenFeignOrder80.class, args);\n    }\n}\n```\n\n\n\n### 4.openfeign层\n\n```java\n@Component\n@FeignClient(\"CLOUD-PAYMENT-SERVICE\")\n@RequestMapping(\"/payment\")\npublic interface PaymentFeignService {\n    /**\n     * 远程调用payment服务的getById方法\n     * @param id 需要查询的payment对象\n     * @return Result\n     */\n    @GetMapping(\"/get/{id}\")\n    public Result getById(@PathVariable String id);\n\n    /**\n     * 远程调用payment服务的save方法\n     * @param payment 需要保存的payment对象\n     * @return Result\n     */\n    @PostMapping(\"/save\")\n    public Result save(@RequestBody Payment payment);\n}\n```\n\n\n\n### 5.controller层\n\n```java\n@RequestMapping(\"/consumer\")\n@RestController\n@Slf4j\npublic class OrderController {\n    @Autowired\n    private PaymentFeignService paymentFeignService;\n\n    @GetMapping(\"/get/{id}\")\n    public Result getById(@PathVariable String id){\n        return paymentFeignService.getById(id);\n    }\n\n    /**\n     * 远程调用payment服务的save方法\n     *\n     * @param payment 需要保存的payment对象\n     * @return Result\n     */\n    @PostMapping(\"/save\")\n    public Result save(@RequestBody Payment payment){\n        return paymentFeignService.save(payment);\n    }\n}\n```\n\n\n\n## 2.openfeign的超时控制\n\n## 	背景\n\nFeign客户端默认等待一秒钟，但是如果服务端处理需要超过一秒钟，导致Feign不想等了就会直接返回报错，为了避免这种情况，所以我们需要设置Feign客户端的超时控制\n\n在yml中添加配置\n\n```\nribbon:\n  ConnectTimeout: 500\n  ReadTimeout: 5000\n```\n\n\n\n## 3.日志打印功能\n\n![image-20200901194240933](https://gitee.com/likeloveC/picture_bed/raw/master/img/8.26/20200901194241.png)\n\n\n\n### 级别\n\n![image-20200901194307025](https://gitee.com/likeloveC/picture_bed/raw/master/img/8.26/20200901194307.png)\n\n\n\n### 配置\n\n在yml文件中添加\n\n```yaml\nlogging:\n  level:\n    #fegin监控的哪个端口，什么级别\n    com.lk.sc.fegin.PaymentFeignService: debug\n```\n\n\n\n添加配置类\n\n\n\n```java\npackage com.lk.sc.config;\n@Configuration\npublic class FeignConfig {\n\n    @Bean\n    Logger.Level feignLoggerLevel() {\n        return Logger.Level.FULL;\n    }\n}\n```\n\n\n\n\n\n# 三、服务降级-hystrix\n\n**原因**\n\n多个微服务之间调用的时候，假设A调用B和C，B和C有调用 其他的微服务，这就是所谓额“==扇出==”。如果扇出的链路上某个微服务的调用响应时间过长或者不可用，对微服务A的调用就会占用越来越多的系统资源，进而引起系统崩溃，这就是“==雪崩效应==”\n\n对于高流量的应用，单一个后端依赖可能会导致所有服务器上的所有资源都在几秒钟内饱和，这可能导致服务之间的延迟增加，备份队列，线程和其他系统资源紧张，导致整个系统发生更多的级联故障\n\n**解决**\n\nhystrix是一个用于处理分布式系统的==延迟==和==容错==的开源库，在分布式系统里，许多依赖不可避免的会调用失败，比如超时，异常。hystrix==能保证在一个依赖出问题的情况下，不会导致整体服务器失败，避免级联故障，以提高分布式系统的高可用==\n\n==断路器==本身是一种开关响应，当某个服务单元故障后，通过==断路器的故障监控==，==向调用方返回一个符合预期的，可处理的备选响应(fallback)，而不是长时间的等待或者抛出异常==\n\n\n\n\n\n## 服务降级\n\n==向调用方返回一个符合预期的，可处理的备选响应(fallback)，而不是长时间的等待或者抛出异常==\n\n**触发情况**\n\n*   程序运行异常\n*   超时\n*   服务熔断触发服务降级\n*   线程池/信号量 打满导致服务降级\n\n\n\n\n\n## 服务熔断\n\n==保险师达到最大服务访问后，直接拒绝访问，拉闸限电，然后调用服务降级的方法返回友好提示==  — ==保险丝跳闸==\n\n\n\n## 服务限流\n\n==秒杀高并发等操作，严禁一窝蜂的过来拥挤，大家排队，一秒钟N个,有序进行==\n\n\n\n## 1.hystrix-payment8001项目构建\n\n![image-20200902163423819](https://gitee.com/likeloveC/picture_bed/raw/master/img/8.26/20200902163423.png)\n\n**pom依赖**\n\n在payment8001的基础上加入\n\n```xml\n<dependency>\n    <groupId>org.springframework.cloud</groupId>\n    <artifactId>spring-cloud-starter-netflix-hystrix</artifactId>\n</dependency>\n```\n\n\n\n**application.yml**\n\n和payment8001相同\n\n\n\n**service**\n\n```java\n@Service\npublic class PaymentService {\n\n    public String ok(int id) {\n        return \"线程池:  \" + Thread.currentThread().getName() + \"ok  id:  \" + id + \"\\t\" + \"O(∩_∩)O哈哈~\";\n    }\n\n    public String timeOut(int id) {\n        //int age = 10/0;\n        try {\n            TimeUnit.MILLISECONDS.sleep(3000);\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n        return \"线程池:  \" + Thread.currentThread().getName() + \" timeOut  id:  \" + id + \"\\t\" + \"O(∩_∩)O哈哈~\" + \"  耗时(秒): \";\n    }\n}\n```\n\n\n\n**controller**\n\n```java\n@RestController\n@Slf4j\npublic class PaymentController {\n    @Resource\n    private PaymentService paymentService;\n    @Value(\"${server.port}\")\n    private String serverPort;\n    @GetMapping(\"/payment/hystrix/ok/{id}\")\n    public String ok(@PathVariable(\"id\") Integer id) {\n        String result = paymentService.ok(id);\n        log.info(\"*****result: \" + result);\n        return result;\n    }\n    @GetMapping(\"/payment/hystrix/timeout/{id}\")\n    public String timeOut(@PathVariable(\"id\") Integer id) {\n        String result = paymentService.timeOut(id);\n        log.info(\"*****result: \" + result);\n        return result;\n    }\n}\n```\n\n\n\n**启动类**\n\n```java\n@SpringBootApplication\n@EnableEurekaClient\npublic class CloudPaymentHsytrix8001 {\n    public static void main(String[] args) {\n        SpringApplication.run(CloudPaymentHsytrix8001.class, args);\n    }\n}\n```\n\n## 2.openfegin-hsytrix-order80项目构建\n\n![image-20200902164425687](https://gitee.com/likeloveC/picture_bed/raw/master/img/8.26/20200902164425.png)\n\npom依赖\n\n加入\n\n```xml\n<dependency>\n    <groupId>org.springframework.cloud</groupId>\n    <artifactId>spring-cloud-starter-netflix-hystrix</artifactId>\n</dependency>\n```\n\napplication.yml\n\n```yaml\nserver:\n  port: 80\n\neureka:\n  client:\n    register-with-eureka: false\n    service-url:\n      defaultZone: http://eureka7001.com:7001/eureka/\n\nfeign:\n  hystrix:\n    enabled: false\nribbon:\n  ConnectTimeout: 500\n  ReadTimeout: 5000\n```\n\n\n\n启动类\n\n```java\n@SpringBootApplication(exclude = DataSourceAutoConfiguration.class)\n@EnableFeignClients\npublic class CloudOpenFeignHsytrixOrder80 {\n    public static void main(String[] args) {\n        SpringApplication.run(CloudOpenFeignHsytrixOrder80.class, args);\n    }\n}\n```\n\n\n\nfeign\n\n```java\n@Component\n@FeignClient(value = \"CLOUD-PAYMENT-HYSTRIX-SERVICE\")\npublic interface PaymentOpenFeign {\n    @GetMapping(\"/payment/hystrix/ok/{id}\")\n    public String ok(@PathVariable(\"id\") Integer id);\n    @GetMapping(\"/payment/hystrix/timeout/{id}\")\n    public String timeOut(@PathVariable(\"id\") Integer id);\n}\n```\n\n\n\ncongtroller\n\n```java\n@RestController\n@Slf4j\n@RequestMapping(\"/order\")\npublic class OrderController {\n\n    @Resource\n    private PaymentOpenFeign paymentOpenFeign;\n    @GetMapping(\"/payment/hystrix/ok/{id}\")\n    public String ok(@PathVariable(\"id\") Integer id) {\n        return paymentOpenFeign.ok(id);\n    }\n    @GetMapping(\"/payment/hystrix/timeout/{id}\")\n    public String timeOut(@PathVariable(\"id\") Integer id) {\n        return paymentOpenFeign.timeOut(id);\n    }\n}\n```\n\n\n\n\n\n\n\n## 3.解决要求\n\n*   超时导致服务器访问变慢\n    *   超时不用等待\n*   出错(宕机或程序运行出错)\n    *   出错兜底\n*   解决\n    *   对方8001超时了，调用者80不能一直卡死等待，必须有服务降级\n    *   对方8001down机了，调用者80不能一直卡斯等待，必须有服务降级\n    *   对方8001ok，调用者80自己出了故障或有自我要求（自己的等待时间小于服务器提供者），自己降级\n\n\n\n## 4.服务降级配置\n\n### cloud-provider-hystrix-payment8001模块\n\n1.在启动类上添加注解\n\n```java\n@EnableCircuitBreaker\n```\n\n\n\n2.在需要服务降级的方法上\n\n```java\n@HystrixCommand(fallbackMethod = \"timeOutHandle\",commandProperties = {\n        @HystrixProperty(name = \"execution.isolation.thread.timeoutInMilliseconds\", value = \"1000\")\n})\npublic String timeOut(int id) {\n    //超时时间\n    int time = 5;\n    //int age = 10/0;\n    try {\n        TimeUnit.SECONDS.sleep(time);\n    } catch (InterruptedException e) {\n        e.printStackTrace();\n    }\n    return \"线程池:  \" + Thread.currentThread().getName() + \" timeOut  id:  \" + id + \"\\t\" + \"O(∩_∩)O哈哈~\" + \"  耗时(秒): \"+time;\n}\n\npublic String timeOutHandle(int id) {\n    return \"线程池:  \" + Thread.currentThread().getName() + \" timeOutHandle  系统繁忙 id:  \" + id + \"\\t\" + \"handle方法\";\n}\n```\n\n\n\n\n\n\n\n### cloud-consumer-openfegin-hsytrix-order80模块\n\n配置fallback，通常放在客户端\n\n\n\n1.在启动类上添加注释\n\n```java\n@EnableHystrix\n```\n\n2.配置文件\n\n![image-20200902172413213](https://gitee.com/likeloveC/picture_bed/raw/master/img/8.26/20200902172413.png)\n\n3.controller\n\n```java\n@GetMapping(\"/payment/hystrix/timeout/{id}\")\n@HystrixCommand(fallbackMethod = \"timeOutHandle\", commandProperties = {\n        @HystrixProperty(name = \"execution.isolation.thread.timeoutInMilliseconds\", value = \"1500\")\n})\npublic String timeOut(@PathVariable(\"id\") Integer id) {\n    int age = 10 / 0;\n    return paymentOpenFeign.timeOut(id);\n}\n\npublic String timeOutHandle(Integer id) {\n    return \"我是消费者80,对方支付系统繁忙请10秒钟后再试或者自己运行出错请检查自己,o(╥﹏╥)o\";\n}\n```\n\n\n\n\n\n### 1.当前问题\n\n*   每个方法都需要有一个兜底方法，代码膨胀\n*   统一和自定义的分开\n\n\n\n### 2.解决\n\n在feign接口上添加注解==@DefaultProperties(defualtFallback = “”)==\n\n*   除了个别重要的核心业务专属，其他普通的可以通过这个注解统一跳转到统一处理结果\n\n\n\n1.在类上添加注解\n\n```java\n@DefaultProperties(defaultFallback = \"globalFallback\")\n```\n\n![image-20200902173231350](https://gitee.com/likeloveC/picture_bed/raw/master/img/8.26/20200902173231.png)\n\n\n\n2.在需要服务降级的方法上添加注解\n\n```java\n@HystrixCommand\n```\n\n![image-20200902173307026](https://gitee.com/likeloveC/picture_bed/raw/master/img/8.26/20200902173307.png)\n\n\n\n3.全局服务降级方法	\n\n仅对当前类有效\n\n```java\n//全局fallback方法\npublic String globalFallback() {\n    return \"Global异常处理信息，请稍后再试，/(ㄒoㄒ)/~~\";\n}\n```\n\n\n\n\n\n\n\n## 5.服务降级feign\n\n![image-20200902173815222](https://gitee.com/likeloveC/picture_bed/raw/master/img/8.26/20200902173815.png)\n\n![image-20200902173927089](https://gitee.com/likeloveC/picture_bed/raw/master/img/8.26/20200902173927.png)\n\n\n\n### 1.写一个类实现PaymentOpenFeign\n\n```java\n@Component\npublic class PaymentOpenFeignFallback  implements PaymentOpenFeign {\n\n    @Override\n    public String ok(Integer id) {\n        return \"ok 的fallback\";\n    }\n\n    @Override\n    public String timeOut(Integer id) {\n        return \"timeOut 的fallback\";\n    }\n}\n```\n\n\n\n### 2.修改PaymentOpenFeign上的注解\n\n添加fallback字段\n\n![image-20200902175734259](https://gitee.com/likeloveC/picture_bed/raw/master/img/8.26/20200902175734.png)\n\n\n\n\n\n### 3.修改yml文件\n\n![image-20200902175807282](https://gitee.com/likeloveC/picture_bed/raw/master/img/8.26/20200902175807.png)\n\n\n\n\n\n### 4.注释掉controller里面关于服务降级的注解\n\n![image-20200902175829205](https://gitee.com/likeloveC/picture_bed/raw/master/img/8.26/20200902175829.png)\n\n\n\n\n\n### 5.测试\n\n![image-20200902175849564](https://gitee.com/likeloveC/picture_bed/raw/master/img/8.26/20200902175849.png)\n\n\n\n\n\n\n\n\n\n## 6.服务熔断\n\n==服务降级->熔断->恢复调用链路==\n\n![image-20200902180747523](https://gitee.com/likeloveC/picture_bed/raw/master/img/8.26/20200902180747.png)\n			服务熔断：当下游的服务因为某种原因突然**变得不可用**或**响应过慢**，上游服务为了保证自己整体服务的可用性，不再继续调用目标服务，直接返回，快速释放资源。如果目标服务情况好转则恢复调用。\n需要说明的是熔断其实是一个框架级的处理，那么这套熔断机制的设计，基本上业内用的是`断路器模式`，如`Martin Fowler`提供的状态转换图如下所示\n\n\n\n![image-20200902181223454](https://gitee.com/likeloveC/picture_bed/raw/master/img/8.26/20200902181223.png)\n\n\n\n-   最开始处于`closed`状态，一旦检测到错误到达一定阈值，便转为`open`状态；\n-   这时候会有个 reset timeout，到了这个时间了，会转移到`half open`状态；\n-   尝试放行一部分请求到后端，一旦检测成功便回归到`closed`状态，即恢复服务；\n\n在Hystrix中，对应配置如下\n\n```java\n//滑动窗口的大小，默认为20\ncircuitBreaker.requestVolumeThreshold \n//过多长时间，熔断器再次检测是否开启，默认为5000，即5s钟\ncircuitBreaker.sleepWindowInMilliseconds \n//错误率，默认50%\ncircuitBreaker.errorThresholdPercentage\n```\n\n每当20个请求中，有50%失败时，熔断器就会打开，此时再调用此服务，将会直接返回失败，不再调远程服务。直到5s钟之后，重新检测该触发条件，判断是否把熔断器关闭，或者继续打开。\n\n这些属于框架层级的实现，我们只要实现对应接口就好！\n\n\n\n\n\n\n\n### 为cloud-provider-hystrix-payment8001添加服务熔断\n\n#### 1.在paymentservice中添加方法\n\n\n\n```java\n//=====服务熔断\n@HystrixCommand(fallbackMethod = \"paymentCircuitBreaker_fallback\", commandProperties = {\n        @HystrixProperty(name = \"circuitBreaker.enabled\", value = \"true\"),// 是否开启断路器\n        @HystrixProperty(name = \"circuitBreaker.requestVolumeThreshold\", value = \"10\"),// 请求次数\n        @HystrixProperty(name = \"circuitBreaker.sleepWindowInMilliseconds\", value = \"10000\"), // 时间窗口期\n        @HystrixProperty(name = \"circuitBreaker.errorThresholdPercentage\", value = \"60\"),// 失败率达到多少后跳闸\n})\npublic String paymentCircuitBreaker(@PathVariable(\"id\") Integer id) {\n    if (id < 0) {\n        throw new RuntimeException(\"******id 不能负数\");\n    }\n    String serialNumber = IdUtil.simpleUUID();\n\n    return Thread.currentThread().getName() + \"\\t\" + \"调用成功，流水号: \" + serialNumber;\n}\n\npublic String paymentCircuitBreaker_fallback(Integer id) {\n    return \"id 不能负数，请稍后再试，/(ㄒoㄒ)/~~   id: \" + id;\n}\n```\n\n\n\n#### 2.在controller中添加方法\n\n\n\n```java\n//====服务熔断\n@GetMapping(\"/payment/circuit/{id}\")\npublic String paymentCircuitBreaker(@PathVariable(\"id\") Integer id) {\n    String result = paymentService.paymentCircuitBreaker(id);\n    log.info(\"****result: \" + result);\n    return result;\n}\n```\n\n\n\n#### 3.测试：\n\n连续多次访问错误的地址\n\nhttp://localhost:8001/payment/circuit/-1\n\n![image-20200902191750070](https://gitee.com/likeloveC/picture_bed/raw/master/img/8.26/20200902191750.png)\n\n\n\n访问正确的\n\n刚开始访问也会出现错误的\n\n![image-20200902191816093](https://gitee.com/likeloveC/picture_bed/raw/master/img/8.26/20200902191816.png)\n\n过几秒后\n\n![image-20200902191832699](https://gitee.com/likeloveC/picture_bed/raw/master/img/8.26/20200902191832.png)\n\n\n\n\n\n#### 4.结论\n\n![image-20200902191950029](https://gitee.com/likeloveC/picture_bed/raw/master/img/8.26/20200902191950.png)\n\n\n\n# 四、服务网关-gateway\n\n==zuul -> gateway==\n\n提供一种简单而有效的方式对API进行路由，以及提供一些强大的过滤器功能，例如：熔断，限流，重试等。==Spring Cloud Gateway是基于WebFlux框架实现的，而WebFlux框架底层使用了高性能的Reactor通信框架netty==；\n\n提供统一的路由方式且基于==Filter==链的方式提供了网关基本的功能；例如：安全，监控/指标，限流	\n\n\n\n![image-20200903175954585](https://gitee.com/likeloveC/picture_bed/raw/master/img/8.26/20200903175954.png)\n\n\n\n## 1.特性\n\n-   动态路由：能匹配任何请求属性\n-   可以对路由指定==Predicate(断言)==和==Filter(过滤器)==\n-   集成了Hystrix的断路器功能\n-   集成了SpringCloud服务发现功能 discover\n-   易于编写的Predicate(断言)和Filter(过滤器)\n-   请求限流功能\n\n-   支持路径重写\n\n\n\n\n\n\n\n## 2.三大核心概念\n\n>   route 路由\n\n路由是构建网关的基本模块，由==ID==， ==目标ur==i 一系列的断言和过滤器组成，如果断言为true则匹配该路由\n\n\n\n>   predicate 断言\n\n参考的是java.util.funciton.Predicate\n\n开发人员可以匹配http请求中的所有内容（比如请求头和请求参数）==如果请求和断言相匹配则进行路由==\n\n\n\n>   filter 过滤器\n\n指的是==gatewayFilter==的实例，==使用过滤器可以在请求被路由前或者后对请求修改==\n\n\n\n\n\n>   总结\n\n一个web请求，通过一些匹配条件，定位到真正的服务节点，并在这个转发过程的前后，进行一些精细化控制，==predicate就是我们的匹配条件==，而==filter，可以理解为一个无所不能的拦截器==。有了这两个元素，在加上目标uri，就可以实现一个具体的路由\n\n\n\n\n\n\n\n## 3.创建gateway9527项目\n\na.依赖\n\n```xml\n<!--gateway-->\n<dependency>\n    <groupId>org.springframework.cloud</groupId>\n    <artifactId>spring-cloud-starter-gateway</artifactId>\n</dependency>\n<!--eureka-client-->\n<dependency>\n    <groupId>org.springframework.cloud</groupId>\n    <artifactId>spring-cloud-starter-netflix-eureka-client</artifactId>\n</dependency>\n<!-- 引入自己定义的api通用包，可以使用Payment支付Entity -->\n<dependency>\n    <groupId>com.like</groupId>\n    <artifactId>cloud-api-common</artifactId>\n    <version>0.0.1-SNAPSHOT</version>\n</dependency>\n<!--一般基础配置类-->\n<dependency>\n    <groupId>org.springframework.boot</groupId>\n    <artifactId>spring-boot-devtools</artifactId>\n    <scope>runtime</scope>\n    <optional>true</optional>\n</dependency>\n<dependency>\n    <groupId>org.projectlombok</groupId>\n    <artifactId>lombok</artifactId>\n    <optional>true</optional>\n</dependency>\n<dependency>\n    <groupId>org.springframework.boot</groupId>\n    <artifactId>spring-boot-starter-test</artifactId>\n    <scope>test</scope>\n</dependency>\n```\n\n\n\n\n\nb.application.yml配置\n\n```yaml\nserver:\n  port: 9527\n\nspring:\n  application:\n    name: cloud-gateway\n  cloud:\n    gateway:\n      discovery:\n        locator:\n          enabled: true #开启从注册中心动态创建路由的功能，利用微服务名进行路由\n      routes:\n        - id: payment_routh #payment_route    #路由的ID，没有固定规则但要求唯一，建议配合服务名\n          uri: http://localhost:8001          #匹配后提供服务的路由地址\n          #uri: lb://cloud-payment-service #匹配后提供服务的路由地址\n          predicates:\n            - Path=/payment/get/**         # 断言，路径相匹配的进行路由\n\n        - id: payment_routh2 #payment_route    #路由的ID，没有固定规则但要求唯一，建议配合服务名\n          uri: http://localhost:8001          #匹配后提供服务的路由地址\n          #uri: lb://cloud-payment-service #匹配后提供服务的路由地址\n          predicates:\n            - Path=/payment/lb/**         # 断言，路径相匹配的进行路由\n            #- After=2020-02-21T15:51:37.485+08:00[Asia/Shanghai]\n            #- Cookie=username,zzyy\n            #- Header=X-Request-Id, \\d+  # 请求头要有X-Request-Id属性并且值为整数的正则表达式\n\neureka:\n  instance:\n    hostname: cloud-gateway-service\n  client: #服务提供者provider注册进eureka服务列表内\n    service-url:\n      register-with-eureka: true\n      fetch-registry: true\n      defaultZone: http://eureka7001.com:7001/eureka\n```\n\n\n\nc.启动类\n\n```java\n@SpringBootApplication(exclude = DataSourceAutoConfiguration.class)\n@EnableEurekaClient\npublic class CloudGateway9527 {\n    public static void main(String[] args) {\n        SpringApplication.run(CloudGateway9527.class, args);\n    }\n}\n```\n\n\n\n\n\nd.测试\n\n![image-20200903184317152](https://gitee.com/likeloveC/picture_bed/raw/master/img/8.26/20200903184317.png)\n\n\n\n![image-20200903184330818](https://gitee.com/likeloveC/picture_bed/raw/master/img/8.26/20200903184330.png)\n\n\n\n\n\n## 4.gateway配置路由的2种方式\n\n使用spring boot 配置类的方式：\n\n```java\n@Configuration\npublic class GateWayConfig {\n\n    /**\n     *  路由映射\n     */\n    @Bean\n    public RouteLocator customRouteLocator(RouteLocatorBuilder routeLocatorBuilder) {\n        RouteLocatorBuilder.Builder routes = routeLocatorBuilder.routes();\n\n        routes.route(\"path_route_atguigu\",\n                     r -> r.path(\"/guonei\")\n                     .uri(\"http://news.baidu.com/guonei\")).build();\n\n        return routes.build();\n    }\n\n    @Bean\n    public RouteLocator customRouteLocator2(RouteLocatorBuilder routeLocatorBuilder) {\n        RouteLocatorBuilder.Builder routes = routeLocatorBuilder.routes();\n        routes.route(\"baidu_news_mil\",  \n                     s -> s.path(\"/mil\")\n                     .uri(\"http://news.baidu.com/mil\")).build();\n        return routes.build();\n    }\n}\n```\n\n\n\n\n\n\n\n## 5.配置动态路由\n\n默认情况下gateway会根据注册中心注册的服务列表，以注册中心上的微服务名为路径的创建==动态路由进行转发，从而实现动态路由的功能==\n\n\n\n修改application.yml文件\n\n```yaml\nspring:\n  application:\n    name: cloud-gateway\n  cloud:\n    gateway:\n      discovery:\n        locator:\n          enabled: true #开启从注册中心动态创建路由的功能，利用微服务名进行路由\n      routes:\n        - id: payment_routh #payment_route    #路由的ID，没有固定规则但要求唯一，建议配合服务名\n          uri: lb://CLOUD-PAYMENT-SERVICE #匹配后提供服务的路由地址\n          predicates:\n            - Path=/payment/get/**         # 断言，路径相匹配的进行路由\n\n        - id: payment_routh2 #payment_route    #路由的ID，没有固定规则但要求唯一，建议配合服务名\n          uri: lb://CLOUD-PAYMENT-SERVICE #匹配后提供服务的路由地址\n          predicates:\n            - Path=/payment/lb/**         # 断言，路径相匹配的进行路由\n```\n\n\n\n\n\n测试\n\n![image-20200903191113505](https://gitee.com/likeloveC/picture_bed/raw/master/img/8.26/20200903191113.png)\n\n![image-20200903191105886](https://gitee.com/likeloveC/picture_bed/raw/master/img/8.26/20200903191105.png)\n\n**结果**\n\n8001和8002会来回调用\n\n\n\n\n\n## 6.predicate\n\ngateway创建Route对象时，使用routePredicateaFctroy 创建 predicate 对象，predicate 对象可以赋值给Route。gateway内置了许多routePredicateaFctroy\n\n![image-20200903191259698](https://gitee.com/likeloveC/picture_bed/raw/master/img/8.26/20200903191259.png)\n\n\n\n```yaml\npredicates:\n  - Path=/payment/lb/**         # 断言，路径相匹配的进行路由\n  #- After=2020-02-21T15:51:37.485+08:00[Asia/Shanghai]\n  #- Cookie=username,zzyy\n  #- Header=X-Request-Id, \\d+  # 请求头要有X-Request-Id属性并且值为整数的正则表达式\n```\n\n\n\n## 7.filter\n\n用法：\n\ntoken鉴权\n\n>   自定义filter\n\n```java\n@Configuration\n@Slf4j\npublic class GatewayFilter  implements GlobalFilter, Ordered {\n\n    @Override\n    public Mono<Void> filter(ServerWebExchange exchange, GatewayFilterChain chain) {\n        String name = exchange.getRequest().getQueryParams().getFirst(\"name\");\n        if (name == null) {\n            log.info(\"用户名为空\");\n            exchange.getResponse().setStatusCode(HttpStatus.NOT_ACCEPTABLE);\n            return exchange.getResponse().setComplete();\n        }\n        return chain.filter(exchange);\n    }\n\n    @Override\n    public int getOrder() {\n        return 0;\n    }\n}\n```\n\n\n\n>   测试\n\n失败：\n\n![image-20200903193826417](https://gitee.com/likeloveC/picture_bed/raw/master/img/8.26/20200903193826.png)\n\n![image-20200903193831196](https://gitee.com/likeloveC/picture_bed/raw/master/img/8.26/20200903193831.png)\n\n\n\n\n\n正确\n\n![image-20200903193903147](https://gitee.com/likeloveC/picture_bed/raw/master/img/8.26/20200903193903.png)\n\n\n\n\n\n\n\n# 五、服务配置-config\n\n## 1、简介\n\n**分布式配置中心**\n\n微服务就是将很多业务拆分成一个个子服务，而每一个服务都需要有一个application.yml(pro)的配置文件，所以一个集中式的，动态的配置管理设施是必不可少的\n\n![image-20200916183315737](https://gitee.com/likeloveC/picture_bed/raw/master/img/8.26/20200916183315.png)\n\n\n\n**服务端**\n\n分布式配置中心，是一个独立的微服务应用，用来连接配置服务器并为客户端提供获取配置信息，加密/解密信息的访问接口\n\n**客户端**\n\n通过指定的配置中心来管理应用资源，以及业务相关的配置内容，并在启动的似乎还从配置中心获取和加载配置信息，配置服务器默认采用git存储配置信息\n\n\n\n\n\n\n\n## 2、作用\n\n1.  集中管理配置文件\n2.  不同环境不同配置\n3.  动态化的配置更新，分环境部署，比如dev、test、prod、bate、release\n4.  运行期间动态调整配置，不需要在每个服部署的机器上编写配置文件，服务会像配置中心统一拉去自己的信息\n5.  当配置发生变化时，服务不需要重启\n6.  将配置信息以rest接口的信息暴露\n\n\n\n## 3、config服务端配置\n\n新建项目cloud-config-center-3344\n\n### 依赖：\n\n```xml\n<dependencies>\n    <!--添加消息总线RabbitMQ支持-->\n    <dependency>\n        <groupId>org.springframework.cloud</groupId>\n        <artifactId>spring-cloud-starter-bus-amqp</artifactId>\n    </dependency>\n    <dependency>\n        <groupId>org.springframework.cloud</groupId>\n        <artifactId>spring-cloud-config-server</artifactId>\n    </dependency>\n    <dependency>\n        <groupId>org.springframework.cloud</groupId>\n        <artifactId>spring-cloud-starter-netflix-eureka-client</artifactId>\n    </dependency>\n    <dependency>\n        <groupId>org.springframework.boot</groupId>\n        <artifactId>spring-boot-starter-web</artifactId>\n    </dependency>\n    <dependency>\n        <groupId>org.springframework.boot</groupId>\n        <artifactId>spring-boot-starter-actuator</artifactId>\n    </dependency>\n    <dependency>\n        <groupId>org.springframework.boot</groupId>\n        <artifactId>spring-boot-devtools</artifactId>\n        <scope>runtime</scope>\n        <optional>true</optional>\n    </dependency>\n    <dependency>\n        <groupId>org.projectlombok</groupId>\n        <artifactId>lombok</artifactId>\n        <optional>true</optional>\n    </dependency>\n    <dependency>\n        <groupId>org.springframework.boot</groupId>\n        <artifactId>spring-boot-starter-test</artifactId>\n        <scope>test</scope>\n    </dependency>\n</dependencies>\n```\n\n\n\n### 配置文件\n\n```yml\nserver:\n  port: 3344\n\nspring:\n  application:\n    name:  cloud-config-center #注册进Eureka服务器的微服务名\n  cloud:\n    config:\n      server:\n        git:\n          uri: git@github.com:likedeke/SpringCloud.git #GitHub上面的git仓库名字\n          ####搜索目录\n          search-paths:\n            - SpringCloud\n      ####读取分支\n      label: master\n```\n\n\n\n### 启动类\n\n```java\n@SpringBootApplication\n@EnableConfigServer\npublic class CloudConfigCenter3344 {\n    public static void main(String[] args) {\n        SpringApplication.run(CloudConfigCenter3344.class, args);\n    }\n}\n```\n\n\n\n### 修改hosts映射\n\n127.0.0.1  config-3344.com\n\n\n\n\n\n\n\n### 测试\n\n在https://github.com/likedeke/SpringCloud中新建一个文件叫做config-dev.yml\n\n报错：reject HostKey: github.com\n\n修改配置文件\n\n![image-20200916190947155](https://gitee.com/likeloveC/picture_bed/raw/master/img/8.26/20200916190947.png)\n\n访问成功\n\n![image-20200916191554693](https://gitee.com/likeloveC/picture_bed/raw/master/img/8.26/20200916191554.png)\n\n命名规范\n\n![image-20200916191301905](https://gitee.com/likeloveC/picture_bed/raw/master/img/8.26/20200916191302.png)\n\n\n\n\n\n## 4、客户端访问ConfigCenter\n\n新建项目：cloud-config-client-3355\n\n\n\n### 依赖\n\n```xml\n<dependency>\n    <groupId>org.springframework.cloud</groupId>\n    <artifactId>spring-cloud-starter-config</artifactId>\n</dependency>\n<dependency>\n    <groupId>org.springframework.cloud</groupId>\n    <artifactId>spring-cloud-starter-netflix-eureka-client</artifactId>\n</dependency>\n<dependency>\n    <groupId>org.springframework.boot</groupId>\n    <artifactId>spring-boot-starter-web</artifactId>\n</dependency>\n<dependency>\n    <groupId>org.springframework.boot</groupId>\n    <artifactId>spring-boot-starter-actuator</artifactId>\n</dependency>\n\n<dependency>\n    <groupId>org.springframework.boot</groupId>\n    <artifactId>spring-boot-devtools</artifactId>\n    <scope>runtime</scope>\n    <optional>true</optional>\n</dependency>\n<dependency>\n    <groupId>org.projectlombok</groupId>\n    <artifactId>lombok</artifactId>\n    <optional>true</optional>\n</dependency>\n<dependency>\n    <groupId>org.springframework.boot</groupId>\n    <artifactId>spring-boot-starter-test</artifactId>\n    <scope>test</scope>\n</dependency>\n```\n\n\n\n### 配置文件\n\n使用bootstrap.yml\n\n**原因**\n\nbootstrap.yml是系统级的，优先级更高，springcloud会创建一个 ==boorstrap context==，作为`application context`的==父上下文==。初始化的时候 ==boorstrap context==负责从外部源加载配置属性并解析配置，这两个上下文共享一个从外部获取的==environment==\n\n![image-20200916192202767](https://gitee.com/likeloveC/picture_bed/raw/master/img/8.26/20200916192202.png)\n\n```\nserver:\n  port: 3355\n\nspring:\n  application:\n    name: config-client\n  cloud:\n    #Config客户端配置\n    config:\n      label: master #分支名称\n      name: config #配置文件名称\n      profile: dev #读取后缀名称   上述3个综合：master分支上config-dev.yml的配置文件被读取http://config-3344.com:3344/master/config-dev.yml\n      uri: http://localhost:3344 #配置中心地址k\n\n  #rabbitmq相关配置 15672是Web管理界面的端口；5672是MQ访问的端口\n  #rabbitmq:\n    #host: localhost\n    #port: 5672\n    #username: guest\n    #password: guest\n\n#服务注册到eureka地址\neureka:\n  client:\n    service-url:\n      defaultZone: http://localhost:7001/eureka\n# 暴露监控端点\n#management:\n  #endpoints:\n    #web:\n      #exposure:\n        #include: \"*\"\n```\n\n\n\n\n\n### 启动类\n\n```java\n@SpringBootApplication\n@EnableEurekaClient\npublic class CloudConfigClient3355 {\n    public static void main(String[] args) {\n        SpringApplication.run(CloudConfigClient3355.class, args);\n    }\n}\n```\n\n\n\n\n\n### 控制层 \n\n测试controller\n\n```java\n@RestController\npublic class HelloController {\n    @Value(\"${config.info}\")\n    private String configInfo;\n    @GetMapping(\"/configinfo\")\n    public String getConfigInfo() {\n        return  configInfo;\n    }\n}\n```\n\n\n\n\n\n### 测试\n\n成功读取到了配置中心的配置文件\n\n![image-20200916193410784](https://gitee.com/likeloveC/picture_bed/raw/master/img/8.26/20200916193410.png)\n\n\n\n\n\n\n\n## 5、动态更新配置文件中的内容\n\n修改配置文件中的内容，客户端马上就可以访问到\n\n### 引入actuator监控\n\n```xml\n<dependency>\n    <groupId>org.springframework.boot</groupId>\n    <artifactId>spring-boot-starter-actuator</artifactId>\n</dependency>\n```\n\n\n\n### 修改配置文件\n\n```yml\nmanagement:\n  endpoints:\n    web:\n      exposure:\n        include: \"*\"\n```\n\n\n\n\n\n### 在HelloController中添加注解\n\n```\n@RefreshScope\n```\n\n\n\n\n\n### 测试\n\n重启3355\n\n![image-20200916194741980](https://gitee.com/likeloveC/picture_bed/raw/master/img/8.26/20200916194742.png)\n\n修改为3\n\n![image-20200916194814145](https://gitee.com/likeloveC/picture_bed/raw/master/img/8.26/20200916194814.png)\n\n3344上\n\n![image-20200916194908320](https://gitee.com/likeloveC/picture_bed/raw/master/img/8.26/20200916194908.png)\n\n3355\n\n![image-20200916194921448](https://gitee.com/likeloveC/picture_bed/raw/master/img/8.26/20200916194921.png)\n\n并没有修改\n\n\n\n### 解决\n\n使用post请求动态刷新\n\n![image-20200916195153104](https://gitee.com/likeloveC/picture_bed/raw/master/img/8.26/20200916195153.png)\n\n再次访问\n\n![image-20200916195206895](https://gitee.com/likeloveC/picture_bed/raw/master/img/8.26/20200916195206.png)\n\n\n\n\n\n# 六、消息总线-bus\n\nbus配合config可以实现配置的动态刷新,一个分布式执行器，用于广播状态更改，事件推送的，也可以当做微服务间的通信通道\n\n## 1、什么是总线\n\n在微服务架构的系统中，通常会使用轻量级的==消息代理来构建一个公用的公共的消息主题，并让系统中所有微服务实例都连接上来==。由于该主题中==产生的消息会被所有实例监听和消费==，所以称他为消息总线。在总线上的各个实例都可以方便的广播一些需要让其他连接在这个上面的实例都知道的消息\n\n**基本原理**\n\nconfigClient实例都监听MQ中一个topic（默认是springCloudBus）。当一个服务刷新数据的时候，他会把这个信息放入topic中，这样其他监听同一个topic的服务就能得到通知，然后去更新自身的配置\n\n\n\n![](https://gitee.com/likeloveC/picture_bed/raw/master/img/8.26/20200916200408.png)\n\n![](https://gitee.com/likeloveC/picture_bed/raw/master/img/8.26/20200916195917.png)\n\n\n\n## 2、docker安装rabbitmq\n\n>   安装\n\ndocker pull rabbitmq:3.7.7-management\n\n>   启动\n\ndocker run -d --hostname localhost --name myrabbit -p 15672:15672 -p 5672:5672 rabbitmq:3.7.7-management\n\n```bash\ndocker exec -it 63ac2bb1bda8 bash\nrabbitmqctl add_user like like\nrabbitmqctl set_permissions -p / like \".*\" \".*\" \".*\"\nrabbitmqctl set_user_tags like administrator\n```\n\n>   访问：\n\nip地址:15672\n\n\n\n\n\n## 3、bus设计思想\n\n1.  利用消息总线触发一个客户端/bus/refresh,而刷新所有客户端的配置\n\n2.  利用消息总线触发一个服务端ConfigServer的/bus/refresh端点，而刷新所有客户端的配置\n\n    使用第二种\n\n![image-20200916205240513](https://gitee.com/likeloveC/picture_bed/raw/master/img/8.26/20200916205240.png)\n\n\n\n## 4、添加依赖\n\n3344 55 66\n\n```xml\n<dependency>\n    <groupId>org.springframework.cloud</groupId>\n    <artifactId>spring-cloud-starter-bus-amqp</artifactId>\n</dependency>\n```\n\n## 5、修改配置文件\n\n3344 55 66\n\n![image-20200916210749458](https://gitee.com/likeloveC/picture_bed/raw/master/img/8.26/20200916210749.png)\n\n\n\n\n\n## 6、问题\n\n不知道为什么报错，在网上找了很久没有找到问题\n\nError creating bean with name \'rabbitMessageChannelBinder\'\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n# 七、消息驱动-stream\n\n消息中间件有很多，比如activemq，rabbitmq，rocketmq，kafka等。消息驱动就能屏蔽底层消息中间件的差异，降低切换成本，统一消息的编程模型\n\n![image-20200917104836585](https://gitee.com/likeloveC/picture_bed/raw/master/img/8.26/20200917104843.png)\n\n==通过定义绑定器，完美的实现了应用程序和消息中间件细节之间的隔离==，通过向应用程序暴露统一的Channel通道，使得应用程序不需要在考虑各种不同的消息中间件的实现\n\n![image-20200917110618278](https://gitee.com/likeloveC/picture_bed/raw/master/img/8.26/20200917110618.png)\n\n\n\n\n\n## 1、常用Api和注解\n\n![image-20200917111227104](https://gitee.com/likeloveC/picture_bed/raw/master/img/8.26/20200917111227.png)\n\n\n\n\n\n## 2、消息提供者-8801\n\n\n\n\n\n\n\n\n\n\n\n# stream和bus因为是rabbitmq相关现在完成不了学完在来\n\n\n\n# 八、链路监控-sleuth\n\n![image-20200917114433952](https://gitee.com/likeloveC/picture_bed/raw/master/img/8.26/20200917114434.png)\n\n\n\n\n\n\n\n# ', 0, 2, 'like', 'like', 'https://huyaimg.msstatic.com/avatar/1014/39/d0dba41e9a3db25510a8cc3065246c_180_135.jpg?1594368665', 0, 'SpringCloud', '2020-09-17 15:16:43', '2020-10-20 11:22:36', 0, 0);

-- ----------------------------
-- Table structure for blog_category
-- ----------------------------
DROP TABLE IF EXISTS `blog_category`;
CREATE TABLE `blog_category`  (
  `id` bigint(40) NOT NULL AUTO_INCREMENT COMMENT '自增id',
  `category` varchar(50) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL COMMENT '博客分类',
  `create_by` datetime(0) NOT NULL COMMENT '创建时间',
  `update_by` datetime(0) NOT NULL COMMENT '更新时间',
  PRIMARY KEY (`id`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 9 CHARACTER SET = utf8 COLLATE = utf8_general_ci ROW_FORMAT = DYNAMIC;

-- ----------------------------
-- Records of blog_category
-- ----------------------------
INSERT INTO `blog_category` VALUES (1, 'Java基础', '2020-09-15 17:21:31', '2020-09-15 17:21:35');
INSERT INTO `blog_category` VALUES (2, 'SpringBoot', '2020-09-15 17:21:51', '2020-09-15 17:21:53');
INSERT INTO `blog_category` VALUES (3, '日常', '2020-09-15 17:22:28', '2020-09-15 17:22:30');
INSERT INTO `blog_category` VALUES (4, '随笔', '2020-09-15 17:22:41', '2020-09-15 17:22:46');
INSERT INTO `blog_category` VALUES (5, 'JVM', '2020-09-15 17:23:00', '2020-09-15 17:23:03');
INSERT INTO `blog_category` VALUES (6, 'JUC', '2020-09-15 17:23:29', '2020-09-15 17:23:34');
INSERT INTO `blog_category` VALUES (7, 'blog of likelove', '2020-09-15 17:23:52', '2020-09-15 17:23:54');
INSERT INTO `blog_category` VALUES (8, 'SpringCloud', '2020-09-16 18:40:27', '2020-09-16 18:40:30');

-- ----------------------------
-- Table structure for blog_comment
-- ----------------------------
DROP TABLE IF EXISTS `blog_comment`;
CREATE TABLE `blog_comment`  (
  `id` int(10) NOT NULL AUTO_INCREMENT COMMENT '自增id',
  `comment_id` varchar(200) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT '0' COMMENT '评论唯一id',
  `topic_category` int(1) NULL DEFAULT NULL COMMENT '1博客 2留言',
  `topic_id` varchar(200) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL COMMENT '评论主题id',
  `user_id` varchar(200) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL COMMENT '评论者id',
  `user_name` varchar(200) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL COMMENT '评论者昵称',
  `user_avatar` varchar(500) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL COMMENT '评论者头像',
  `content` longtext CHARACTER SET utf8 COLLATE utf8_general_ci NULL COMMENT '评论内容',
  `love` int(8) NULL DEFAULT 0 COMMENT '喜欢的人数',
  `create_by` datetime(0) NOT NULL COMMENT '创建时间',
  `update_by` datetime(0) NOT NULL COMMENT '更新时间',
  `is_deleted` tinyint(1) UNSIGNED NULL DEFAULT 0 COMMENT '逻辑删除 1（true）已删除， 0（false）未删除',
  `replyid` int(8) NULL DEFAULT NULL COMMENT '回复的哪一条评论就保存哪一条评论的id',
  `pid` int(8) NULL DEFAULT NULL COMMENT '一级评论的id',
  PRIMARY KEY (`id`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 34 CHARACTER SET = utf8 COLLATE = utf8_general_ci ROW_FORMAT = DYNAMIC;

-- ----------------------------
-- Records of blog_comment
-- ----------------------------
INSERT INTO `blog_comment` VALUES (31, '0', 2, '', 'like', 'like', 'https://huyaimg.msstatic.com/avatar/1014/39/d0dba41e9a3db25510a8cc3065246c_180_135.jpg?1594368665', '真不错', 0, '2020-09-23 18:18:35', '2020-09-23 18:18:35', 0, NULL, NULL);
INSERT INTO `blog_comment` VALUES (32, '0', 1, '55', 'like', 'like', 'https://huyaimg.msstatic.com/avatar/1014/39/d0dba41e9a3db25510a8cc3065246c_180_135.jpg?1594368665', '真不错', 1, '2020-09-23 18:19:20', '2020-09-23 18:19:34', 0, NULL, NULL);
INSERT INTO `blog_comment` VALUES (33, '0', 2, '', 'like', 'like', 'https://huyaimg.msstatic.com/avatar/1014/39/d0dba41e9a3db25510a8cc3065246c_180_135.jpg?1594368665', 'test', 0, '2020-10-20 11:21:19', '2020-10-20 11:21:19', 0, NULL, NULL);

-- ----------------------------
-- Table structure for blog_commentreplay
-- ----------------------------
DROP TABLE IF EXISTS `blog_commentreplay`;
CREATE TABLE `blog_commentreplay`  (
  `id` int(10) NOT NULL AUTO_INCREMENT COMMENT '唯一主键',
  `be_commented` int(10) NULL DEFAULT NULL COMMENT '被评论的评论的id',
  `beuser_name` varchar(255) CHARACTER SET utf8 COLLATE utf8_unicode_ci NULL DEFAULT NULL COMMENT '被评论的人的名字',
  `comment` longtext CHARACTER SET utf8 COLLATE utf8_unicode_ci NULL COMMENT '评论内容',
  `user_name` varchar(255) CHARACTER SET utf8 COLLATE utf8_unicode_ci NULL DEFAULT NULL COMMENT '评论者名字',
  `user_avatar` varchar(255) CHARACTER SET utf8 COLLATE utf8_unicode_ci NULL DEFAULT NULL COMMENT '评论者头像',
  `create_by` datetime(0) NULL DEFAULT NULL COMMENT '创建时间',
  `update_by` datetime(0) NULL DEFAULT NULL COMMENT '更新时间',
  PRIMARY KEY (`id`) USING BTREE
) ENGINE = MyISAM AUTO_INCREMENT = 2 CHARACTER SET = utf8 COLLATE = utf8_unicode_ci ROW_FORMAT = DYNAMIC;

-- ----------------------------
-- Records of blog_commentreplay
-- ----------------------------
INSERT INTO `blog_commentreplay` VALUES (1, 1, 'like', '这是小王的回复', '小王', '1', '2020-09-11 16:54:24', '2020-09-11 16:54:26');

-- ----------------------------
-- Table structure for user
-- ----------------------------
DROP TABLE IF EXISTS `user`;
CREATE TABLE `user`  (
  `id` int(10) NOT NULL AUTO_INCREMENT COMMENT '自增id',
  `uid` varchar(200) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL COMMENT '用户编号',
  `username` varchar(100) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL COMMENT '用户名',
  `password` varchar(200) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL COMMENT '密码',
  `avatar` varchar(500) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL COMMENT '用户头像',
  `login_date` datetime(0) NULL DEFAULT NULL COMMENT '登录时间',
  `is_online` tinyint(1) UNSIGNED NULL DEFAULT NULL COMMENT '是否在线 1（true）在线， 0（false）离线',
  `is_deleted` tinyint(1) UNSIGNED NULL DEFAULT 0 COMMENT '逻辑删除 1（true）已删除， 0（false）未删除',
  `create_by` datetime(0) NOT NULL COMMENT '创建时间',
  `update_by` datetime(0) NOT NULL COMMENT '更新时间',
  PRIMARY KEY (`id`) USING BTREE,
  UNIQUE INDEX `1`(`uid`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 7 CHARACTER SET = utf8 COLLATE = utf8_general_ci ROW_FORMAT = DYNAMIC;

-- ----------------------------
-- Records of user
-- ----------------------------
INSERT INTO `user` VALUES (1, 'like', 'like', '1', 'https://huyaimg.msstatic.com/avatar/1014/39/d0dba41e9a3db25510a8cc3065246c_180_135.jpg?1594368665', NULL, NULL, 0, '2020-09-14 20:36:36', '2020-09-14 20:36:36');
INSERT INTO `user` VALUES (2, 'lj', 'lj', '123456', 'https://oss.aliyuncs.com/aliyun_id_photo_bucket/default_handsome.jpg', NULL, NULL, 0, '2020-09-14 20:46:39', '2020-09-14 20:46:39');
INSERT INTO `user` VALUES (3, 'zzzzz', 'zzzzz', '123456', 'https://oss.aliyuncs.com/aliyun_id_photo_bucket/default_handsome.jpg', NULL, NULL, 0, '2020-09-16 12:24:21', '2020-09-16 12:24:21');
INSERT INTO `user` VALUES (4, 'admin', 'admin', '123456', 'https://oss.aliyuncs.com/aliyun_id_photo_bucket/default_handsome.jpg', NULL, NULL, 0, '2020-09-16 14:37:38', '2020-09-16 14:37:38');
INSERT INTO `user` VALUES (5, 'surblue', 'surblue', 'wanyihao', 'https://oss.aliyuncs.com/aliyun_id_photo_bucket/default_handsome.jpg', NULL, NULL, 0, '2020-09-16 15:34:59', '2020-09-16 15:34:59');
INSERT INTO `user` VALUES (6, '13123123123', '13123123123', '13123123123', 'https://huyaimg.msstatic.com/avatar/1014/39/d0dba41e9a3db25510a8cc3065246c_180_135.jpg?1594368665', NULL, NULL, 0, '2020-09-20 08:53:20', '2020-09-20 08:53:20');

-- ----------------------------
-- Table structure for user_info
-- ----------------------------
DROP TABLE IF EXISTS `user_info`;
CREATE TABLE `user_info`  (
  `id` int(10) UNSIGNED ZEROFILL NOT NULL AUTO_INCREMENT COMMENT '自增id',
  `uid` varchar(200) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL COMMENT '用户id',
  `nickname` varchar(80) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL COMMENT '用户昵称',
  `realname` varchar(80) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL COMMENT '真实姓名',
  `qq` varchar(20) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL COMMENT 'QQ',
  `wechat` varchar(200) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL COMMENT 'WeChat',
  `email` varchar(500) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL COMMENT '邮箱',
  `phone` varchar(20) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL COMMENT '手机',
  `work` varchar(200) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL COMMENT '工作',
  `address` varchar(500) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL COMMENT '地址',
  `hobby` varchar(500) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL COMMENT '爱好',
  `intro` varchar(2000) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL COMMENT '自我介绍',
  `create_by` datetime(0) NOT NULL COMMENT '创建时间',
  `update_by` datetime(0) NOT NULL COMMENT '更新时间',
  `is_deleted` tinyint(1) UNSIGNED NOT NULL DEFAULT 0 COMMENT '逻辑删除 1（true）已删除， 0（false）未删除',
  PRIMARY KEY (`id`) USING BTREE,
  UNIQUE INDEX `1`(`uid`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 7 CHARACTER SET = utf8 COLLATE = utf8_general_ci ROW_FORMAT = DYNAMIC;

-- ----------------------------
-- Records of user_info
-- ----------------------------
INSERT INTO `user_info` VALUES (0000000001, 'like', 'like', '李可', '980650920', 'l980650920', '980650920@qq.com', '13789983260', '无', NULL, '123', '这个比懒得一b', '2020-09-14 20:36:36', '2020-10-20 11:20:52', 0);
INSERT INTO `user_info` VALUES (0000000002, 'lj', 'lj', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, '2020-09-14 20:46:39', '2020-09-14 20:46:39', 0);
INSERT INTO `user_info` VALUES (0000000003, 'zzzzz', 'zzzzz', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, '2020-09-16 12:24:21', '2020-09-16 12:24:21', 0);
INSERT INTO `user_info` VALUES (0000000004, 'admin', 'admin', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, '2020-09-16 14:37:38', '2020-09-16 14:37:38', 0);
INSERT INTO `user_info` VALUES (0000000005, 'surblue', 'surblue', '李可', '123', '123', '123', '123', '123', NULL, '123', '1233', '2020-09-16 15:34:59', '2020-09-16 15:36:33', 0);
INSERT INTO `user_info` VALUES (0000000006, '13123123123', '13123123123', '123', 'dasd', 'asd', 'asd', '123', 'aqsd', NULL, 'asd', 'asd', '2020-09-20 08:53:20', '2020-09-20 08:56:40', 0);

SET FOREIGN_KEY_CHECKS = 1;
